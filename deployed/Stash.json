{"/tmp/geth-compile-solidity367589821:PaymentAgent":{"code":"0x6060604052341561000c57fe5b60405160208061152883398101604052515b5b60008054600160a060020a03191633600160a060020a03161790555b60008054600160a060020a03191633600160a060020a031617815560015560058190555b505b6114b8806100706000396000f300606060405236156100d55763ffffffff60e060020a60003504166301810b1881146100d75780630ae94616146100fe5780632a5b1c70146101235780632ae6a3b21461015157806341c0e1b51461017657806350cdb4b11461018857806377681490146101a3578063893d20e8146101b85780639cb5d0dc146101e4578063a6f9dae1146101f9578063b721e11814610217578063b8f770051461022f578063be6554dc14610251578063cd193fa514610269578063e59d9481146102bf578063fb6cb61f146102e4578063ff88b6a614610313575bfe5b34156100df57fe5b6100ea600435610334565b604080519115158252519081900360200190f35b341561010657fe5b610111600435610759565b60408051918252519081900360200190f35b341561012b57fe5b61011160043560243560443560643561077c565b60408051918252519081900360200190f35b341561015957fe5b6101116004356109ae565b60408051918252519081900360200190f35b341561017e57fe5b610186610a38565b005b341561019057fe5b610186600435602435604435610a60565b005b34156101ab57fe5b610186600435610ba0565b005b34156101c057fe5b6101c8610bc6565b60408051600160a060020a039092168252519081900360200190f35b34156101ec57fe5b610186600435610bd6565b005b341561020157fe5b610186600160a060020a0360043516610c7f565b005b341561021f57fe5b610186600435602435610cc8565b005b341561023757fe5b610111610d49565b60408051918252519081900360200190f35b341561025957fe5b610186600435602435610d50565b005b341561027157fe5b61027c600435610dd1565b604080518681526020810186905290810184905260608101839052608081018260028111156102a757fe5b60ff1681526020019550505050505060405180910390f35b34156102c757fe5b610111600435610e15565b60408051918252519081900360200190f35b34156102ec57fe5b6101c8600435610e3e565b60408051600160a060020a039092168252519081900360200190f35b341561031b57fe5b610186600435600160a060020a0360243516610e59565b005b60008054819081908190819033600160a060020a039081169116146103595760006000fd5b8593505b600084131561073057600092505b6002548310156107235760006003600060028681548110151561038a57fe5b906000526020600020900160005b5054815260208082019290925260409081016000908120548251840182905282517f7398ab180000000000000000000000000000000000000000000000000000000081529251600160a060020a0390911693637398ab1893600480820194929392918390030190829087803b151561040c57fe5b6102c65a03f1151561041a57fe5b50506040515191909112905061042f57610717565b600091505b60065482101561071757600680548390811061044c57fe5b906000526020600020906005020160005b50905060028381548110151561046f57fe5b906000526020600020900160005b50546001820154148015906104a6575060005b600482015460ff1660028111156104a357fe5b14155b156104b05761070b565b60016006838154811015156104c157fe5b906000526020600020906005020160005b50600401805460ff191660018360028111156104ea57fe5b02179055506003600060068481548110151561050257fe5b906000526020600020906005020160005b5060010154815260208101919091526040908101600090812054600384015483517fabc7b72300000000000000000000000000000000000000000000000000000000815260048101919091529251600160a060020a039091169263abc7b72392602480830193919282900301818387803b151561058c57fe5b6102c65a03f1151561059a57fe5b505050600360006006848154811015156105b057fe5b906000526020600020906005020160005b5060020154815260208101919091526040908101600090812054600384015483517fa08c5c2f00000000000000000000000000000000000000000000000000000000815260048101919091529251600160a060020a039091169263a08c5c2f92602480830193919282900301818387803b151561063a57fe5b6102c65a03f1151561064857fe5b50505060006003600060068581548110151561066057fe5b906000526020600020906005020160005b5060010154815260208082019290925260409081016000908120548251840182905282517f7398ab180000000000000000000000000000000000000000000000000000000081529251600160a060020a0390911693637398ab1893600480820194929392918390030190829087803b15156106e857fe5b6102c65a03f115156106f657fe5b50506040515191909112905061070b57610717565b5b600190910190610434565b5b60019092019161036b565b5b6000199093019261035d565b600061073a610ed4565b1315610749576000945061074e565b600194505b5b5b50505050919050565b600280548290811061076757fe5b906000526020600020900160005b5054905081565b600081600081121561078e5760006000fd5b600154859085908214806107a3575060015481145b156109a05760068054906107ba9060018301610fb1565b506006805489919060001981019081106107d057fe5b906000526020600020906005020160005b50556006805488919060001981019081106107f857fe5b906000526020600020906005020160005b506001015560068054879190600019810190811061082357fe5b906000526020600020906005020160005b506002015560068054869190600019810190811061084e57fe5b906000526020600020906005020160005b50600301556006805460009190600019810190811061087a57fe5b906000526020600020906005020160005b50600401805460ff191660018360028111156108a357fe5b02179055506000878152600360205260408082205481517fa08c5c2f000000000000000000000000000000000000000000000000000000008152600481018990529151600160a060020a039091169263a08c5c2f926024808201939182900301818387803b151561091057fe5b6102c65a03f1151561091e57fe5b5050506000868152600360205260408082205481517fabc7b723000000000000000000000000000000000000000000000000000000008152600481018990529151600160a060020a039091169263abc7b723926024808201939182900301818387803b151561098957fe5b6102c65a03f1151561099757fe5b50506006549450505b5b5b50505b50949350505050565b6000818152600360209081526040808320548151830184905281517f12065fe00000000000000000000000000000000000000000000000000000000081529151600160a060020a039091169283926312065fe0926004808301939282900301818887803b1515610a1a57fe5b6102c65a03f11515610a2857fe5b5050604051519250505b50919050565b60005433600160a060020a0390811691161415610a5d57600054600160a060020a0316ff5b5b565b60008381526003602052604080822054848352912054600154600160a060020a039283169290911690851415610aeb5781600160a060020a0316638c1fdf82846040518263ffffffff1660e060020a02815260040180828152602001915050600060405180830381600087803b1515610ad557fe5b6102c65a03f11515610ae357fe5b505050610b42565b81600160a060020a03166369c83743846040518263ffffffff1660e060020a02815260040180828152602001915050600060405180830381600087803b1515610b3057fe5b6102c65a03f11515610b3e57fe5b5050505b80600160a060020a03166304d4f624846040518263ffffffff1660e060020a02815260040180828152602001915050600060405180830381600087803b1515610b8757fe5b6102c65a03f11515610b9557fe5b5050505b5050505050565b60005433600160a060020a03908116911614610bbc5760006000fd5b60018190555b5b50565b600054600160a060020a03165b90565b6000805433600160a060020a03908116911614610bf35760006000fd5b816000610bfe610fe3565b9182526020820152604080519182900301906000f0801515610c1c57fe5b6000838152600360205260409020805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038316179055600280549192509060018101610c668382610ff3565b916000526020600020900160005b50839055505b5b5050565b60005433600160a060020a03908116911614610c9b5760006000fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790555b5b50565b6000828152600360205260408082205481517f04d4f624000000000000000000000000000000000000000000000000000000008152600481018590529151600160a060020a039091169283926304d4f624926024808301939282900301818387803b1515610d3257fe5b6102c65a03f11515610d4057fe5b5050505b505050565b6006545b90565b6000828152600360205260408082205481517f8c1fdf82000000000000000000000000000000000000000000000000000000008152600481018590529151600160a060020a03909116928392638c1fdf82926024808301939282900301818387803b1515610d3257fe5b6102c65a03f11515610d4057fe5b5050505b505050565b6006805482908110610ddf57fe5b906000526020600020906005020160005b5080546001820154600283015460038401546004909401549294509092909160ff1685565b6000600282815481101515610e2657fe5b906000526020600020900160005b505490505b919050565b600360205260009081526040902054600160a060020a031681565b60005433600160a060020a03908116911614610e755760006000fd5b6000828152600360205260409020805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790556002805460018101610c668382610ff3565b916000526020600020900160005b50839055505b5b5050565b600080805b600254811015610fa857600060036000600284815481101515610ef857fe5b906000526020600020900160005b5054815260208082019290925260409081016000908120548251840182905282517f7398ab180000000000000000000000000000000000000000000000000000000081529251600160a060020a0390911693637398ab1893600480820194929392918390030190829087803b1515610f7a57fe5b6102c65a03f11515610f8857fe5b505050604051805190501215610f9f576001909101905b5b600101610ed9565b8192505b505090565b815481835581811511610d4457600502816005028360005260206000209182019101610d44919061101d565b5b505050565b60405161040d8061108083390190565b815481835581811511610d4457600083815260209020610d4491810190830161105e565b5b505050565b610bd391905b808211156110575760008082556001820181905560028201819055600382015560048101805460ff19169055600501611023565b5090565b90565b610bd391905b808211156110575760008155600101611064565b5090565b9056006060604052341561000c57fe5b60405160408061040d8339810160405280516020909101515b5b60008054600160a060020a03191633600160a060020a03161790555b6001829055600281905560038190555b50505b6103a9806100646000396000f300606060405236156100c25763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166304d4f62481146100c457806309218e91146100d957806312065fe0146100fb57806327d358011461011d57806341c0e1b51461013f5780635ce239501461015157806369c83743146101755780637398ab181461018a578063893d20e8146101ac5780638c1fdf82146101d8578063a08c5c2f146101ed578063abc7b72314610202578063b69ef8a814610217575bfe5b34156100cc57fe5b6100d7600435610239565b005b34156100e157fe5b6100e9610262565b60408051918252519081900360200190f35b341561010357fe5b6100e9610268565b60408051918252519081900360200190f35b341561012557fe5b6100e961026f565b60408051918252519081900360200190f35b341561014757fe5b6100d7610275565b005b341561015957fe5b61016161029d565b604080519115158252519081900360200190f35b341561017d57fe5b6100d76004356102a9565b005b341561019257fe5b6100e96102d3565b60408051918252519081900360200190f35b34156101b457fe5b6101bc6102da565b60408051600160a060020a039092168252519081900360200190f35b34156101e057fe5b6100d76004356102ea565b005b34156101f557fe5b6100d7600435610324565b005b341561020a57fe5b6100d760043561034e565b005b341561021f57fe5b6100e9610377565b60408051918252519081900360200190f35b60005433600160a060020a039081169116146102555760006000fd5b60028054820190555b5b50565b60035481565b6002545b90565b60015481565b60005433600160a060020a039081169116141561029a57600054600160a060020a0316ff5b5b565b60035460009012155b90565b60005433600160a060020a039081169116146102c55760006000fd5b6002805482900390555b5b50565b6003545b90565b600054600160a060020a03165b90565b60005433600160a060020a039081169116146103065760006000fd5b6002548113156102c55760006000fd5b6002805482900390555b5b50565b60005433600160a060020a039081169116146103405760006000fd5b6003805482900390555b5b50565b60005433600160a060020a0390811691161461036a5760006000fd5b60038054820190555b5b50565b600254815600a165627a7a72305820999aa782764d7227c0264e310edb27cbb49f1443c448bb2c94ab827ddbe28d420029a165627a7a7230582095094d03f7bc8c808679926c589bc75c6a9d1dc1e317cde0ab9825cec79c32de0029","info":{"source":"/* pragma solidity ^0.4.2; */\n\ncontract owned{\n  address owner;\n  \n  function owned() {\n    owner = msg.sender;\n  }\n  \n  modifier onlyowner() {\n      if(msg.sender!=owner) throw; _;\n  }\n\n  function getOwner() constant returns (address) {\n      return owner;\n  }\n\n}\n\ncontract mortal is owned {\n  function kill() {\n    if (msg.sender == owner) suicide(owner); \n  }\n}\n\n/* To be deploy by PaymentAgent, so that no human has owner access */\ncontract Stash is mortal {\n    bytes32 public bankName;\n    int public balance;\n    int public position;\n\n    function Stash(bytes32 _bankName, int _balance) {\n\tbankName = _bankName;\n\tbalance = _balance;\n\tposition = _balance;\n    }\n\n    function credit(int _crAmt) onlyowner {\n\tbalance += _crAmt;\n    }\n\n    function debit(int _dAmt) onlyowner {\n\tbalance -= _dAmt;\n    }\n\n    function safe_debit(int _dAmt) onlyowner {\n\tif (_dAmt > balance) throw;\n\tbalance -= _dAmt;\n    }\n\n    function inc_position(int amt) onlyowner {\n\tposition += amt;\n    }\n\n    function dec_position(int amt) onlyowner {\n\tposition -= amt;\n    }\n\n    function getBalance() constant returns (int) {\n    \treturn balance;\n    }\n\n    function getPosition() constant returns (int) {\n    \treturn position;\n    }\n\n    function isSolvent() constant returns (bool) {\n    \treturn position >= 0;\n    }\n}\n\n\n/* To be deploy by regulator, so that regulator has owner access */\ncontract PaymentAgent is mortal {\n    bytes32 private ownedStash;\n    bytes32[] public stashNames;\n    mapping (bytes32 => address) public stashRegistry;\n    bool resolving; \t\t/* true when resolving gridlock */\n    uint maxQueueLen;           /* queue depth trigger */\n\n    enum TxState { Active, Inactive, Locked }\n    \n    struct Tx {\n        bytes32 txRef; \n        bytes32 sender;\n        bytes32 receiver;\n        int amount;\n\tTxState state;\n    }\n\n    Tx[] public txQueue; /* 0-indexed array */\n\n    modifier isInvoled(bytes32 _sender, bytes32 _receiver) {\n\tif(ownedStash == _sender || ownedStash == _receiver) _;\n    }\n\n    modifier isPositive(int _amount) { if (_amount < 0 ) throw;_; }\n\n    function PaymentAgent(uint _maxQueueLen) {\n\towner = msg.sender;\n\townedStash = \"\";\n\tmaxQueueLen = _maxQueueLen;\n    }\n\n    function changeOwner(address _newOwner) onlyowner {\n\towner = _newOwner;\n    }\n\n    /* @deployment:\n       privateFor = everyone */\n    function createStash(bytes32 _bankName) onlyowner {\n\taddress stash = new Stash(_bankName, 0);\n\tstashRegistry[_bankName] = stash;\n\tstashNames.push(_bankName);\n    }\n\n    function getStashName(uint index) returns(bytes32) {\n\treturn stashNames[index];\n    }\n\n    /* @deployment:\n       privateFor = everyone\n\n       register an existing stash */\n    function registerStash(bytes32 _bankName, address _addr) onlyowner {\n\tstashRegistry[_bankName] = Stash(_addr);\n\tstashNames.push(_bankName);\n    }\n    \n    /* @depolyment:\n       privateFor = MAS and owner node */\n    function markStash(bytes32 _bankName) onlyowner {\n\townedStash = _bankName;\n    }\n\n    /* @live:\n       privateFor = MAS and participating node */\n    function submitTx(bytes32 _txRef, bytes32 _sender, bytes32 _receiver, int _amount)\n\tisPositive(_amount) isInvoled(_sender, _receiver) external returns(uint) {\n\ttxQueue.length++;\n\ttxQueue[txQueue.length-1].txRef = _txRef;\n\ttxQueue[txQueue.length-1].sender = _sender;\n\ttxQueue[txQueue.length-1].receiver = _receiver;\n\ttxQueue[txQueue.length-1].amount = _amount;\n\ttxQueue[txQueue.length-1].state = TxState.Active;\n\t/* update position */\n\t/* Stash sender = Stash(stashRegistry[_sender]).dec; */\n\tStash(stashRegistry[_sender]).dec_position(_amount);\n\tStash(stashRegistry[_receiver]).inc_position(_amount);\n\t/* decide whether to resolve gridlock */\n\t/* if (txQueue.length >= maxQueueLen) { */\n\t/*     resolve(); */\n\t/* } */\n\treturn txQueue.length;\n    }\n\n    function get_n_deficits() private returns(int) {\n\tint count = 0;\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    if (Stash(stashRegistry[stashNames[j]]).getPosition() < 0 ) { count++; }\n\t}\n\treturn count;\n    }\n\n    /* only can be called by regulator\n\n       To avoid the outermost while loop in the original algorithm,\n       the number of iteration is limited to @param steps\n       If the resolution fails one can always resume in the next transaction\n       (or function call) */\n    function resolve(int steps) onlyowner external returns(bool) {\n\tfor (int i = steps; i > 0; i--) {\n\t    for (uint j = 0; j < stashNames.length; j++) {\n\t\tif (Stash(stashRegistry[stashNames[j]]).getPosition() >= 0) { continue; }\n\t\tfor (uint k = 0; k < txQueue.length; k++) {\n\t\t    var tx = txQueue[k];\n\t\t    if (tx.sender != stashNames[j] && tx.state != TxState.Active) { continue; }\n\t\t    txQueue[k].state = TxState.Inactive;\n\t\t    Stash(stashRegistry[txQueue[k].sender]).inc_position(tx.amount);\n\t\t    Stash(stashRegistry[txQueue[k].receiver]).dec_position(tx.amount);\n\t\t    if (Stash(stashRegistry[txQueue[k].sender]).getPosition() >= 0) { break; }\n\t\t}\n\t    }\n\t}\n\tif (get_n_deficits() > 0) { return false; }\n\telse { return true; }\n    }\n    \n    function settle() onlyowner private returns(bool) {\n\tif (get_n_deficits() > 0) { throw; }\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    Stash stash = Stash(stashRegistry[stashNames[j]]);\n\t    int net_diff = stash.getPosition() - stash.getBalance();\n\t    if (net_diff > 0) {\n\t\tstash.credit(net_diff);\n\t    } else if (net_diff < 0) {\n\t\tstash.safe_debit(-net_diff);\n\t    }\n\t}\n\tfor (uint k = 0; k < txQueue.length; k++) {\n\t    txQueue[k].state = TxState.Active;\n\t    var tx = txQueue[k];\n\t    Stash(stashRegistry[tx.sender]).dec_position(tx.amount);\n\t    Stash(stashRegistry[tx.receiver]).inc_position(tx.amount);\n\t}\n    }\n/*     /\\* only can be called by regulator *\\/ */\n/*     function resolve(int steps) onlyowner external returns(bool) { */\n/* \tfor (uint i = steps; i > 0: i--) { */\n/* \t    for (uint j = 0; i < stashNames.length; j++) { */\n/* \t\tif (stashRegistry[stashNames[i]].getPosition < 0) { */\n/*     for (uint k = 0; k < txQueue.length; k++) { */\n/*     tx = txQueue[k]; */\n/*     if (txQueue[k].sender == stashNames[i] && txQueue[k].state == TxState.Active) { */\n/*     txQueue[k].state = TxState.Inactive; */\n/*     stashRegistry[txQueue[k].sender].inc_position(_amount); */\n/*     stashRegistry[txQueue[k].receiver].dec_position(_amount); */\n/*     if (stashRegistry[txQueue[k].sender] >= 0) { break; } */\n/* } */\n/* } */\n/* \t\t} */\n/* \t    } */\n/* \t} */\n\t\n/* \treturn finished; */\n/*     } */\n\n\n    /* @depolyment, @live:\n       privateFor = MAS and participating node */\n    function transfer(bytes32 _src, bytes32 _dest, int _amount) {\n    \tStash src = Stash(stashRegistry[_src]);\n\tStash dest = Stash(stashRegistry[_dest]);\n\tif (_src == ownedStash) {\n\t    src.safe_debit(_amount);\n\t} else {\n\t    src.debit(_amount);\n\t}\n\tdest.credit(_amount);\n    }\n\n    /* @depolyment:\n       privateFor == MAS and owner node\n       amount == 0\n       \n       @live:\n       privateFor == MAS and owner node */\n    function pledge(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.credit(_amount);\n    }\n\n    /* @live:\n       privateFor = MAS and owner node */\n    function redeem(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.safe_debit(_amount);\n    }\n\n    /* @live:\n       for stashes not owned by you this returns the net bilateral position */\n    function getStash(bytes32 _bankName) constant returns (int) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\treturn stash.getBalance();\n    }\n\n    function getQueueLength() public constant returns(uint) {\n        return txQueue.length;\n    }\n}\n\n\n/* Public contract for holding RefData */\n/* contract RefData is mortal { */\n    \n/*     struct transaction { */\n/* \tbool exists; */\n/* \tuint timestamp; */\n/* \tbool active; */\n/*     } */\n\n/*     struct Bank { */\n/* \tstring name; */\n/* \tbool authorized; */\n/* \tbool exists; */\n/* \taddress authorizedSender; */\n/*     } */\n\n/*     address public regulator; */\n    \n/*     mapping (bytes32 => transaction) public transactions; */\n    \n/*     mapping (address => Bank) public banks; */\n    \n/*     function addTransaction (bytes32 _transactionID) { */\n/*         transactions[_transactionID].exists=true; */\n/*         transactions[_transactionID].timestamp=block.timestamp; */\n/*         transactions[_transactionID].active=true; */\n/*     } */\n\n/*     function getTransactionExistance (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].exists); */\n/*     } */\n\n/*     function getTransactionState (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].blocked); */\n/*     } */\n\n/*     function getTransactionTimestamp (bytes32 _transactionID) public constant  */\n/* \treturns (uint) { */\n/*         return (transactions[_transactionID].timestamp); */\n/*     } */\n\n/*     function bankExist (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].exists); */\n/*     } */\n\n/*     function bankAuthorized (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].authorized); */\n/*     } */\n\n/*     function getBankSender (address _contract) public constant  */\n/* \treturns (address) { */\n/*         return (banks[_contract].authorizedSender); */\n/*     } */\n\n/*     function activate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=true; */\n/* \t} */\n/*     } */\n\n/*     function inactivate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=false; */\n/* \t} */\n/*     } */\n\n/*     function addBank (string _name, address _contract, address _sender) onlyowner { */\n/* \tbanks[_contract].name=_name; */\n/* \tbanks[_contract].exists=true; */\n/* \tbanks[_contract].authorized=true; */\n/* \tbanks[_contract].authorizedSender=_sender; */\n/*     } */\n\n/*     function blockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=false; */\n/*     } */\n\n/*     function unblockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=true; */\n/*     } */\n\n/* } */\n","language":"Solidity","languageVersion":"0.4.11","compilerVersion":"0.4.11","compilerOptions":"--combined-json bin,abi,userdoc,devdoc --add-std --optimize","abiDefinition":[{"constant":false,"inputs":[{"name":"steps","type":"int256"}],"name":"resolve","outputs":[{"name":"","type":"bool"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"stashNames","outputs":[{"name":"","type":"bytes32"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_txRef","type":"bytes32"},{"name":"_sender","type":"bytes32"},{"name":"_receiver","type":"bytes32"},{"name":"_amount","type":"int256"}],"name":"submitTx","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"_bankName","type":"bytes32"}],"name":"getStash","outputs":[{"name":"","type":"int256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[],"name":"kill","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_src","type":"bytes32"},{"name":"_dest","type":"bytes32"},{"name":"_amount","type":"int256"}],"name":"transfer","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_bankName","type":"bytes32"}],"name":"markStash","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_bankName","type":"bytes32"}],"name":"createStash","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_newOwner","type":"address"}],"name":"changeOwner","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_bankName","type":"bytes32"},{"name":"_amount","type":"int256"}],"name":"pledge","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getQueueLength","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_bankName","type":"bytes32"},{"name":"_amount","type":"int256"}],"name":"redeem","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"txQueue","outputs":[{"name":"txRef","type":"bytes32"},{"name":"sender","type":"bytes32"},{"name":"receiver","type":"bytes32"},{"name":"amount","type":"int256"},{"name":"state","type":"uint8"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"index","type":"uint256"}],"name":"getStashName","outputs":[{"name":"","type":"bytes32"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"","type":"bytes32"}],"name":"stashRegistry","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_bankName","type":"bytes32"},{"name":"_addr","type":"address"}],"name":"registerStash","outputs":[],"payable":false,"type":"function"},{"inputs":[{"name":"_maxQueueLen","type":"uint256"}],"payable":false,"type":"constructor"}],"userDoc":{"methods":{}},"developerDoc":{"methods":{}}}},"/tmp/geth-compile-solidity367589821:Stash":{"code":"0x6060604052341561000c57fe5b60405160408061040d8339810160405280516020909101515b5b60008054600160a060020a03191633600160a060020a03161790555b6001829055600281905560038190555b50505b6103a9806100646000396000f300606060405236156100c25763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166304d4f62481146100c457806309218e91146100d957806312065fe0146100fb57806327d358011461011d57806341c0e1b51461013f5780635ce239501461015157806369c83743146101755780637398ab181461018a578063893d20e8146101ac5780638c1fdf82146101d8578063a08c5c2f146101ed578063abc7b72314610202578063b69ef8a814610217575bfe5b34156100cc57fe5b6100d7600435610239565b005b34156100e157fe5b6100e9610262565b60408051918252519081900360200190f35b341561010357fe5b6100e9610268565b60408051918252519081900360200190f35b341561012557fe5b6100e961026f565b60408051918252519081900360200190f35b341561014757fe5b6100d7610275565b005b341561015957fe5b61016161029d565b604080519115158252519081900360200190f35b341561017d57fe5b6100d76004356102a9565b005b341561019257fe5b6100e96102d3565b60408051918252519081900360200190f35b34156101b457fe5b6101bc6102da565b60408051600160a060020a039092168252519081900360200190f35b34156101e057fe5b6100d76004356102ea565b005b34156101f557fe5b6100d7600435610324565b005b341561020a57fe5b6100d760043561034e565b005b341561021f57fe5b6100e9610377565b60408051918252519081900360200190f35b60005433600160a060020a039081169116146102555760006000fd5b60028054820190555b5b50565b60035481565b6002545b90565b60015481565b60005433600160a060020a039081169116141561029a57600054600160a060020a0316ff5b5b565b60035460009012155b90565b60005433600160a060020a039081169116146102c55760006000fd5b6002805482900390555b5b50565b6003545b90565b600054600160a060020a03165b90565b60005433600160a060020a039081169116146103065760006000fd5b6002548113156102c55760006000fd5b6002805482900390555b5b50565b60005433600160a060020a039081169116146103405760006000fd5b6003805482900390555b5b50565b60005433600160a060020a0390811691161461036a5760006000fd5b60038054820190555b5b50565b600254815600a165627a7a72305820999aa782764d7227c0264e310edb27cbb49f1443c448bb2c94ab827ddbe28d420029","info":{"source":"/* pragma solidity ^0.4.2; */\n\ncontract owned{\n  address owner;\n  \n  function owned() {\n    owner = msg.sender;\n  }\n  \n  modifier onlyowner() {\n      if(msg.sender!=owner) throw; _;\n  }\n\n  function getOwner() constant returns (address) {\n      return owner;\n  }\n\n}\n\ncontract mortal is owned {\n  function kill() {\n    if (msg.sender == owner) suicide(owner); \n  }\n}\n\n/* To be deploy by PaymentAgent, so that no human has owner access */\ncontract Stash is mortal {\n    bytes32 public bankName;\n    int public balance;\n    int public position;\n\n    function Stash(bytes32 _bankName, int _balance) {\n\tbankName = _bankName;\n\tbalance = _balance;\n\tposition = _balance;\n    }\n\n    function credit(int _crAmt) onlyowner {\n\tbalance += _crAmt;\n    }\n\n    function debit(int _dAmt) onlyowner {\n\tbalance -= _dAmt;\n    }\n\n    function safe_debit(int _dAmt) onlyowner {\n\tif (_dAmt > balance) throw;\n\tbalance -= _dAmt;\n    }\n\n    function inc_position(int amt) onlyowner {\n\tposition += amt;\n    }\n\n    function dec_position(int amt) onlyowner {\n\tposition -= amt;\n    }\n\n    function getBalance() constant returns (int) {\n    \treturn balance;\n    }\n\n    function getPosition() constant returns (int) {\n    \treturn position;\n    }\n\n    function isSolvent() constant returns (bool) {\n    \treturn position >= 0;\n    }\n}\n\n\n/* To be deploy by regulator, so that regulator has owner access */\ncontract PaymentAgent is mortal {\n    bytes32 private ownedStash;\n    bytes32[] public stashNames;\n    mapping (bytes32 => address) public stashRegistry;\n    bool resolving; \t\t/* true when resolving gridlock */\n    uint maxQueueLen;           /* queue depth trigger */\n\n    enum TxState { Active, Inactive, Locked }\n    \n    struct Tx {\n        bytes32 txRef; \n        bytes32 sender;\n        bytes32 receiver;\n        int amount;\n\tTxState state;\n    }\n\n    Tx[] public txQueue; /* 0-indexed array */\n\n    modifier isInvoled(bytes32 _sender, bytes32 _receiver) {\n\tif(ownedStash == _sender || ownedStash == _receiver) _;\n    }\n\n    modifier isPositive(int _amount) { if (_amount < 0 ) throw;_; }\n\n    function PaymentAgent(uint _maxQueueLen) {\n\towner = msg.sender;\n\townedStash = \"\";\n\tmaxQueueLen = _maxQueueLen;\n    }\n\n    function changeOwner(address _newOwner) onlyowner {\n\towner = _newOwner;\n    }\n\n    /* @deployment:\n       privateFor = everyone */\n    function createStash(bytes32 _bankName) onlyowner {\n\taddress stash = new Stash(_bankName, 0);\n\tstashRegistry[_bankName] = stash;\n\tstashNames.push(_bankName);\n    }\n\n    function getStashName(uint index) returns(bytes32) {\n\treturn stashNames[index];\n    }\n\n    /* @deployment:\n       privateFor = everyone\n\n       register an existing stash */\n    function registerStash(bytes32 _bankName, address _addr) onlyowner {\n\tstashRegistry[_bankName] = Stash(_addr);\n\tstashNames.push(_bankName);\n    }\n    \n    /* @depolyment:\n       privateFor = MAS and owner node */\n    function markStash(bytes32 _bankName) onlyowner {\n\townedStash = _bankName;\n    }\n\n    /* @live:\n       privateFor = MAS and participating node */\n    function submitTx(bytes32 _txRef, bytes32 _sender, bytes32 _receiver, int _amount)\n\tisPositive(_amount) isInvoled(_sender, _receiver) external returns(uint) {\n\ttxQueue.length++;\n\ttxQueue[txQueue.length-1].txRef = _txRef;\n\ttxQueue[txQueue.length-1].sender = _sender;\n\ttxQueue[txQueue.length-1].receiver = _receiver;\n\ttxQueue[txQueue.length-1].amount = _amount;\n\ttxQueue[txQueue.length-1].state = TxState.Active;\n\t/* update position */\n\t/* Stash sender = Stash(stashRegistry[_sender]).dec; */\n\tStash(stashRegistry[_sender]).dec_position(_amount);\n\tStash(stashRegistry[_receiver]).inc_position(_amount);\n\t/* decide whether to resolve gridlock */\n\t/* if (txQueue.length >= maxQueueLen) { */\n\t/*     resolve(); */\n\t/* } */\n\treturn txQueue.length;\n    }\n\n    function get_n_deficits() private returns(int) {\n\tint count = 0;\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    if (Stash(stashRegistry[stashNames[j]]).getPosition() < 0 ) { count++; }\n\t}\n\treturn count;\n    }\n\n    /* only can be called by regulator\n\n       To avoid the outermost while loop in the original algorithm,\n       the number of iteration is limited to @param steps\n       If the resolution fails one can always resume in the next transaction\n       (or function call) */\n    function resolve(int steps) onlyowner external returns(bool) {\n\tfor (int i = steps; i > 0; i--) {\n\t    for (uint j = 0; j < stashNames.length; j++) {\n\t\tif (Stash(stashRegistry[stashNames[j]]).getPosition() >= 0) { continue; }\n\t\tfor (uint k = 0; k < txQueue.length; k++) {\n\t\t    var tx = txQueue[k];\n\t\t    if (tx.sender != stashNames[j] && tx.state != TxState.Active) { continue; }\n\t\t    txQueue[k].state = TxState.Inactive;\n\t\t    Stash(stashRegistry[txQueue[k].sender]).inc_position(tx.amount);\n\t\t    Stash(stashRegistry[txQueue[k].receiver]).dec_position(tx.amount);\n\t\t    if (Stash(stashRegistry[txQueue[k].sender]).getPosition() >= 0) { break; }\n\t\t}\n\t    }\n\t}\n\tif (get_n_deficits() > 0) { return false; }\n\telse { return true; }\n    }\n    \n    function settle() onlyowner private returns(bool) {\n\tif (get_n_deficits() > 0) { throw; }\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    Stash stash = Stash(stashRegistry[stashNames[j]]);\n\t    int net_diff = stash.getPosition() - stash.getBalance();\n\t    if (net_diff > 0) {\n\t\tstash.credit(net_diff);\n\t    } else if (net_diff < 0) {\n\t\tstash.safe_debit(-net_diff);\n\t    }\n\t}\n\tfor (uint k = 0; k < txQueue.length; k++) {\n\t    txQueue[k].state = TxState.Active;\n\t    var tx = txQueue[k];\n\t    Stash(stashRegistry[tx.sender]).dec_position(tx.amount);\n\t    Stash(stashRegistry[tx.receiver]).inc_position(tx.amount);\n\t}\n    }\n/*     /\\* only can be called by regulator *\\/ */\n/*     function resolve(int steps) onlyowner external returns(bool) { */\n/* \tfor (uint i = steps; i > 0: i--) { */\n/* \t    for (uint j = 0; i < stashNames.length; j++) { */\n/* \t\tif (stashRegistry[stashNames[i]].getPosition < 0) { */\n/*     for (uint k = 0; k < txQueue.length; k++) { */\n/*     tx = txQueue[k]; */\n/*     if (txQueue[k].sender == stashNames[i] && txQueue[k].state == TxState.Active) { */\n/*     txQueue[k].state = TxState.Inactive; */\n/*     stashRegistry[txQueue[k].sender].inc_position(_amount); */\n/*     stashRegistry[txQueue[k].receiver].dec_position(_amount); */\n/*     if (stashRegistry[txQueue[k].sender] >= 0) { break; } */\n/* } */\n/* } */\n/* \t\t} */\n/* \t    } */\n/* \t} */\n\t\n/* \treturn finished; */\n/*     } */\n\n\n    /* @depolyment, @live:\n       privateFor = MAS and participating node */\n    function transfer(bytes32 _src, bytes32 _dest, int _amount) {\n    \tStash src = Stash(stashRegistry[_src]);\n\tStash dest = Stash(stashRegistry[_dest]);\n\tif (_src == ownedStash) {\n\t    src.safe_debit(_amount);\n\t} else {\n\t    src.debit(_amount);\n\t}\n\tdest.credit(_amount);\n    }\n\n    /* @depolyment:\n       privateFor == MAS and owner node\n       amount == 0\n       \n       @live:\n       privateFor == MAS and owner node */\n    function pledge(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.credit(_amount);\n    }\n\n    /* @live:\n       privateFor = MAS and owner node */\n    function redeem(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.safe_debit(_amount);\n    }\n\n    /* @live:\n       for stashes not owned by you this returns the net bilateral position */\n    function getStash(bytes32 _bankName) constant returns (int) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\treturn stash.getBalance();\n    }\n\n    function getQueueLength() public constant returns(uint) {\n        return txQueue.length;\n    }\n}\n\n\n/* Public contract for holding RefData */\n/* contract RefData is mortal { */\n    \n/*     struct transaction { */\n/* \tbool exists; */\n/* \tuint timestamp; */\n/* \tbool active; */\n/*     } */\n\n/*     struct Bank { */\n/* \tstring name; */\n/* \tbool authorized; */\n/* \tbool exists; */\n/* \taddress authorizedSender; */\n/*     } */\n\n/*     address public regulator; */\n    \n/*     mapping (bytes32 => transaction) public transactions; */\n    \n/*     mapping (address => Bank) public banks; */\n    \n/*     function addTransaction (bytes32 _transactionID) { */\n/*         transactions[_transactionID].exists=true; */\n/*         transactions[_transactionID].timestamp=block.timestamp; */\n/*         transactions[_transactionID].active=true; */\n/*     } */\n\n/*     function getTransactionExistance (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].exists); */\n/*     } */\n\n/*     function getTransactionState (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].blocked); */\n/*     } */\n\n/*     function getTransactionTimestamp (bytes32 _transactionID) public constant  */\n/* \treturns (uint) { */\n/*         return (transactions[_transactionID].timestamp); */\n/*     } */\n\n/*     function bankExist (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].exists); */\n/*     } */\n\n/*     function bankAuthorized (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].authorized); */\n/*     } */\n\n/*     function getBankSender (address _contract) public constant  */\n/* \treturns (address) { */\n/*         return (banks[_contract].authorizedSender); */\n/*     } */\n\n/*     function activate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=true; */\n/* \t} */\n/*     } */\n\n/*     function inactivate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=false; */\n/* \t} */\n/*     } */\n\n/*     function addBank (string _name, address _contract, address _sender) onlyowner { */\n/* \tbanks[_contract].name=_name; */\n/* \tbanks[_contract].exists=true; */\n/* \tbanks[_contract].authorized=true; */\n/* \tbanks[_contract].authorizedSender=_sender; */\n/*     } */\n\n/*     function blockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=false; */\n/*     } */\n\n/*     function unblockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=true; */\n/*     } */\n\n/* } */\n","language":"Solidity","languageVersion":"0.4.11","compilerVersion":"0.4.11","compilerOptions":"--combined-json bin,abi,userdoc,devdoc --add-std --optimize","abiDefinition":[{"constant":false,"inputs":[{"name":"_crAmt","type":"int256"}],"name":"credit","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"position","outputs":[{"name":"","type":"int256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getBalance","outputs":[{"name":"","type":"int256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"bankName","outputs":[{"name":"","type":"bytes32"}],"payable":false,"type":"function"},{"constant":false,"inputs":[],"name":"kill","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"isSolvent","outputs":[{"name":"","type":"bool"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_dAmt","type":"int256"}],"name":"debit","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getPosition","outputs":[{"name":"","type":"int256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_dAmt","type":"int256"}],"name":"safe_debit","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"amt","type":"int256"}],"name":"dec_position","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"amt","type":"int256"}],"name":"inc_position","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"balance","outputs":[{"name":"","type":"int256"}],"payable":false,"type":"function"},{"inputs":[{"name":"_bankName","type":"bytes32"},{"name":"_balance","type":"int256"}],"payable":false,"type":"constructor"}],"userDoc":{"methods":{}},"developerDoc":{"methods":{}}}},"/tmp/geth-compile-solidity367589821:mortal":{"code":"0x60606040525b60008054600160a060020a03191633600160a060020a03161790555b5b610112806100316000396000f300606060405263ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166341c0e1b581146043578063893d20e8146052575bfe5b3415604a57fe5b60506088565b005b3415605957fe5b605f60c9565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b6000543373ffffffffffffffffffffffffffffffffffffffff9081169116141560c65760005473ffffffffffffffffffffffffffffffffffffffff16ff5b5b565b60005473ffffffffffffffffffffffffffffffffffffffff165b905600a165627a7a7230582015237b8119b4da750a5803a1532af824c195c18bb516363b67011bdc306234670029","info":{"source":"/* pragma solidity ^0.4.2; */\n\ncontract owned{\n  address owner;\n  \n  function owned() {\n    owner = msg.sender;\n  }\n  \n  modifier onlyowner() {\n      if(msg.sender!=owner) throw; _;\n  }\n\n  function getOwner() constant returns (address) {\n      return owner;\n  }\n\n}\n\ncontract mortal is owned {\n  function kill() {\n    if (msg.sender == owner) suicide(owner); \n  }\n}\n\n/* To be deploy by PaymentAgent, so that no human has owner access */\ncontract Stash is mortal {\n    bytes32 public bankName;\n    int public balance;\n    int public position;\n\n    function Stash(bytes32 _bankName, int _balance) {\n\tbankName = _bankName;\n\tbalance = _balance;\n\tposition = _balance;\n    }\n\n    function credit(int _crAmt) onlyowner {\n\tbalance += _crAmt;\n    }\n\n    function debit(int _dAmt) onlyowner {\n\tbalance -= _dAmt;\n    }\n\n    function safe_debit(int _dAmt) onlyowner {\n\tif (_dAmt > balance) throw;\n\tbalance -= _dAmt;\n    }\n\n    function inc_position(int amt) onlyowner {\n\tposition += amt;\n    }\n\n    function dec_position(int amt) onlyowner {\n\tposition -= amt;\n    }\n\n    function getBalance() constant returns (int) {\n    \treturn balance;\n    }\n\n    function getPosition() constant returns (int) {\n    \treturn position;\n    }\n\n    function isSolvent() constant returns (bool) {\n    \treturn position >= 0;\n    }\n}\n\n\n/* To be deploy by regulator, so that regulator has owner access */\ncontract PaymentAgent is mortal {\n    bytes32 private ownedStash;\n    bytes32[] public stashNames;\n    mapping (bytes32 => address) public stashRegistry;\n    bool resolving; \t\t/* true when resolving gridlock */\n    uint maxQueueLen;           /* queue depth trigger */\n\n    enum TxState { Active, Inactive, Locked }\n    \n    struct Tx {\n        bytes32 txRef; \n        bytes32 sender;\n        bytes32 receiver;\n        int amount;\n\tTxState state;\n    }\n\n    Tx[] public txQueue; /* 0-indexed array */\n\n    modifier isInvoled(bytes32 _sender, bytes32 _receiver) {\n\tif(ownedStash == _sender || ownedStash == _receiver) _;\n    }\n\n    modifier isPositive(int _amount) { if (_amount < 0 ) throw;_; }\n\n    function PaymentAgent(uint _maxQueueLen) {\n\towner = msg.sender;\n\townedStash = \"\";\n\tmaxQueueLen = _maxQueueLen;\n    }\n\n    function changeOwner(address _newOwner) onlyowner {\n\towner = _newOwner;\n    }\n\n    /* @deployment:\n       privateFor = everyone */\n    function createStash(bytes32 _bankName) onlyowner {\n\taddress stash = new Stash(_bankName, 0);\n\tstashRegistry[_bankName] = stash;\n\tstashNames.push(_bankName);\n    }\n\n    function getStashName(uint index) returns(bytes32) {\n\treturn stashNames[index];\n    }\n\n    /* @deployment:\n       privateFor = everyone\n\n       register an existing stash */\n    function registerStash(bytes32 _bankName, address _addr) onlyowner {\n\tstashRegistry[_bankName] = Stash(_addr);\n\tstashNames.push(_bankName);\n    }\n    \n    /* @depolyment:\n       privateFor = MAS and owner node */\n    function markStash(bytes32 _bankName) onlyowner {\n\townedStash = _bankName;\n    }\n\n    /* @live:\n       privateFor = MAS and participating node */\n    function submitTx(bytes32 _txRef, bytes32 _sender, bytes32 _receiver, int _amount)\n\tisPositive(_amount) isInvoled(_sender, _receiver) external returns(uint) {\n\ttxQueue.length++;\n\ttxQueue[txQueue.length-1].txRef = _txRef;\n\ttxQueue[txQueue.length-1].sender = _sender;\n\ttxQueue[txQueue.length-1].receiver = _receiver;\n\ttxQueue[txQueue.length-1].amount = _amount;\n\ttxQueue[txQueue.length-1].state = TxState.Active;\n\t/* update position */\n\t/* Stash sender = Stash(stashRegistry[_sender]).dec; */\n\tStash(stashRegistry[_sender]).dec_position(_amount);\n\tStash(stashRegistry[_receiver]).inc_position(_amount);\n\t/* decide whether to resolve gridlock */\n\t/* if (txQueue.length >= maxQueueLen) { */\n\t/*     resolve(); */\n\t/* } */\n\treturn txQueue.length;\n    }\n\n    function get_n_deficits() private returns(int) {\n\tint count = 0;\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    if (Stash(stashRegistry[stashNames[j]]).getPosition() < 0 ) { count++; }\n\t}\n\treturn count;\n    }\n\n    /* only can be called by regulator\n\n       To avoid the outermost while loop in the original algorithm,\n       the number of iteration is limited to @param steps\n       If the resolution fails one can always resume in the next transaction\n       (or function call) */\n    function resolve(int steps) onlyowner external returns(bool) {\n\tfor (int i = steps; i > 0; i--) {\n\t    for (uint j = 0; j < stashNames.length; j++) {\n\t\tif (Stash(stashRegistry[stashNames[j]]).getPosition() >= 0) { continue; }\n\t\tfor (uint k = 0; k < txQueue.length; k++) {\n\t\t    var tx = txQueue[k];\n\t\t    if (tx.sender != stashNames[j] && tx.state != TxState.Active) { continue; }\n\t\t    txQueue[k].state = TxState.Inactive;\n\t\t    Stash(stashRegistry[txQueue[k].sender]).inc_position(tx.amount);\n\t\t    Stash(stashRegistry[txQueue[k].receiver]).dec_position(tx.amount);\n\t\t    if (Stash(stashRegistry[txQueue[k].sender]).getPosition() >= 0) { break; }\n\t\t}\n\t    }\n\t}\n\tif (get_n_deficits() > 0) { return false; }\n\telse { return true; }\n    }\n    \n    function settle() onlyowner private returns(bool) {\n\tif (get_n_deficits() > 0) { throw; }\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    Stash stash = Stash(stashRegistry[stashNames[j]]);\n\t    int net_diff = stash.getPosition() - stash.getBalance();\n\t    if (net_diff > 0) {\n\t\tstash.credit(net_diff);\n\t    } else if (net_diff < 0) {\n\t\tstash.safe_debit(-net_diff);\n\t    }\n\t}\n\tfor (uint k = 0; k < txQueue.length; k++) {\n\t    txQueue[k].state = TxState.Active;\n\t    var tx = txQueue[k];\n\t    Stash(stashRegistry[tx.sender]).dec_position(tx.amount);\n\t    Stash(stashRegistry[tx.receiver]).inc_position(tx.amount);\n\t}\n    }\n/*     /\\* only can be called by regulator *\\/ */\n/*     function resolve(int steps) onlyowner external returns(bool) { */\n/* \tfor (uint i = steps; i > 0: i--) { */\n/* \t    for (uint j = 0; i < stashNames.length; j++) { */\n/* \t\tif (stashRegistry[stashNames[i]].getPosition < 0) { */\n/*     for (uint k = 0; k < txQueue.length; k++) { */\n/*     tx = txQueue[k]; */\n/*     if (txQueue[k].sender == stashNames[i] && txQueue[k].state == TxState.Active) { */\n/*     txQueue[k].state = TxState.Inactive; */\n/*     stashRegistry[txQueue[k].sender].inc_position(_amount); */\n/*     stashRegistry[txQueue[k].receiver].dec_position(_amount); */\n/*     if (stashRegistry[txQueue[k].sender] >= 0) { break; } */\n/* } */\n/* } */\n/* \t\t} */\n/* \t    } */\n/* \t} */\n\t\n/* \treturn finished; */\n/*     } */\n\n\n    /* @depolyment, @live:\n       privateFor = MAS and participating node */\n    function transfer(bytes32 _src, bytes32 _dest, int _amount) {\n    \tStash src = Stash(stashRegistry[_src]);\n\tStash dest = Stash(stashRegistry[_dest]);\n\tif (_src == ownedStash) {\n\t    src.safe_debit(_amount);\n\t} else {\n\t    src.debit(_amount);\n\t}\n\tdest.credit(_amount);\n    }\n\n    /* @depolyment:\n       privateFor == MAS and owner node\n       amount == 0\n       \n       @live:\n       privateFor == MAS and owner node */\n    function pledge(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.credit(_amount);\n    }\n\n    /* @live:\n       privateFor = MAS and owner node */\n    function redeem(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.safe_debit(_amount);\n    }\n\n    /* @live:\n       for stashes not owned by you this returns the net bilateral position */\n    function getStash(bytes32 _bankName) constant returns (int) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\treturn stash.getBalance();\n    }\n\n    function getQueueLength() public constant returns(uint) {\n        return txQueue.length;\n    }\n}\n\n\n/* Public contract for holding RefData */\n/* contract RefData is mortal { */\n    \n/*     struct transaction { */\n/* \tbool exists; */\n/* \tuint timestamp; */\n/* \tbool active; */\n/*     } */\n\n/*     struct Bank { */\n/* \tstring name; */\n/* \tbool authorized; */\n/* \tbool exists; */\n/* \taddress authorizedSender; */\n/*     } */\n\n/*     address public regulator; */\n    \n/*     mapping (bytes32 => transaction) public transactions; */\n    \n/*     mapping (address => Bank) public banks; */\n    \n/*     function addTransaction (bytes32 _transactionID) { */\n/*         transactions[_transactionID].exists=true; */\n/*         transactions[_transactionID].timestamp=block.timestamp; */\n/*         transactions[_transactionID].active=true; */\n/*     } */\n\n/*     function getTransactionExistance (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].exists); */\n/*     } */\n\n/*     function getTransactionState (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].blocked); */\n/*     } */\n\n/*     function getTransactionTimestamp (bytes32 _transactionID) public constant  */\n/* \treturns (uint) { */\n/*         return (transactions[_transactionID].timestamp); */\n/*     } */\n\n/*     function bankExist (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].exists); */\n/*     } */\n\n/*     function bankAuthorized (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].authorized); */\n/*     } */\n\n/*     function getBankSender (address _contract) public constant  */\n/* \treturns (address) { */\n/*         return (banks[_contract].authorizedSender); */\n/*     } */\n\n/*     function activate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=true; */\n/* \t} */\n/*     } */\n\n/*     function inactivate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=false; */\n/* \t} */\n/*     } */\n\n/*     function addBank (string _name, address _contract, address _sender) onlyowner { */\n/* \tbanks[_contract].name=_name; */\n/* \tbanks[_contract].exists=true; */\n/* \tbanks[_contract].authorized=true; */\n/* \tbanks[_contract].authorizedSender=_sender; */\n/*     } */\n\n/*     function blockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=false; */\n/*     } */\n\n/*     function unblockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=true; */\n/*     } */\n\n/* } */\n","language":"Solidity","languageVersion":"0.4.11","compilerVersion":"0.4.11","compilerOptions":"--combined-json bin,abi,userdoc,devdoc --add-std --optimize","abiDefinition":[{"constant":false,"inputs":[],"name":"kill","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"}],"userDoc":{"methods":{}},"developerDoc":{"methods":{}}}},"/tmp/geth-compile-solidity367589821:owned":{"code":"0x6060604052341561000c57fe5b5b60008054600160a060020a03191633600160a060020a03161790555b5b60b8806100386000396000f300606060405263ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663893d20e881146039575bfe5b3415604057fe5b6046606f565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b60005473ffffffffffffffffffffffffffffffffffffffff165b905600a165627a7a72305820e966d14cff2e848cb0671e7d0bec47c2ddc0a5eed3622c431a3a0b08d45d60520029","info":{"source":"/* pragma solidity ^0.4.2; */\n\ncontract owned{\n  address owner;\n  \n  function owned() {\n    owner = msg.sender;\n  }\n  \n  modifier onlyowner() {\n      if(msg.sender!=owner) throw; _;\n  }\n\n  function getOwner() constant returns (address) {\n      return owner;\n  }\n\n}\n\ncontract mortal is owned {\n  function kill() {\n    if (msg.sender == owner) suicide(owner); \n  }\n}\n\n/* To be deploy by PaymentAgent, so that no human has owner access */\ncontract Stash is mortal {\n    bytes32 public bankName;\n    int public balance;\n    int public position;\n\n    function Stash(bytes32 _bankName, int _balance) {\n\tbankName = _bankName;\n\tbalance = _balance;\n\tposition = _balance;\n    }\n\n    function credit(int _crAmt) onlyowner {\n\tbalance += _crAmt;\n    }\n\n    function debit(int _dAmt) onlyowner {\n\tbalance -= _dAmt;\n    }\n\n    function safe_debit(int _dAmt) onlyowner {\n\tif (_dAmt > balance) throw;\n\tbalance -= _dAmt;\n    }\n\n    function inc_position(int amt) onlyowner {\n\tposition += amt;\n    }\n\n    function dec_position(int amt) onlyowner {\n\tposition -= amt;\n    }\n\n    function getBalance() constant returns (int) {\n    \treturn balance;\n    }\n\n    function getPosition() constant returns (int) {\n    \treturn position;\n    }\n\n    function isSolvent() constant returns (bool) {\n    \treturn position >= 0;\n    }\n}\n\n\n/* To be deploy by regulator, so that regulator has owner access */\ncontract PaymentAgent is mortal {\n    bytes32 private ownedStash;\n    bytes32[] public stashNames;\n    mapping (bytes32 => address) public stashRegistry;\n    bool resolving; \t\t/* true when resolving gridlock */\n    uint maxQueueLen;           /* queue depth trigger */\n\n    enum TxState { Active, Inactive, Locked }\n    \n    struct Tx {\n        bytes32 txRef; \n        bytes32 sender;\n        bytes32 receiver;\n        int amount;\n\tTxState state;\n    }\n\n    Tx[] public txQueue; /* 0-indexed array */\n\n    modifier isInvoled(bytes32 _sender, bytes32 _receiver) {\n\tif(ownedStash == _sender || ownedStash == _receiver) _;\n    }\n\n    modifier isPositive(int _amount) { if (_amount < 0 ) throw;_; }\n\n    function PaymentAgent(uint _maxQueueLen) {\n\towner = msg.sender;\n\townedStash = \"\";\n\tmaxQueueLen = _maxQueueLen;\n    }\n\n    function changeOwner(address _newOwner) onlyowner {\n\towner = _newOwner;\n    }\n\n    /* @deployment:\n       privateFor = everyone */\n    function createStash(bytes32 _bankName) onlyowner {\n\taddress stash = new Stash(_bankName, 0);\n\tstashRegistry[_bankName] = stash;\n\tstashNames.push(_bankName);\n    }\n\n    function getStashName(uint index) returns(bytes32) {\n\treturn stashNames[index];\n    }\n\n    /* @deployment:\n       privateFor = everyone\n\n       register an existing stash */\n    function registerStash(bytes32 _bankName, address _addr) onlyowner {\n\tstashRegistry[_bankName] = Stash(_addr);\n\tstashNames.push(_bankName);\n    }\n    \n    /* @depolyment:\n       privateFor = MAS and owner node */\n    function markStash(bytes32 _bankName) onlyowner {\n\townedStash = _bankName;\n    }\n\n    /* @live:\n       privateFor = MAS and participating node */\n    function submitTx(bytes32 _txRef, bytes32 _sender, bytes32 _receiver, int _amount)\n\tisPositive(_amount) isInvoled(_sender, _receiver) external returns(uint) {\n\ttxQueue.length++;\n\ttxQueue[txQueue.length-1].txRef = _txRef;\n\ttxQueue[txQueue.length-1].sender = _sender;\n\ttxQueue[txQueue.length-1].receiver = _receiver;\n\ttxQueue[txQueue.length-1].amount = _amount;\n\ttxQueue[txQueue.length-1].state = TxState.Active;\n\t/* update position */\n\t/* Stash sender = Stash(stashRegistry[_sender]).dec; */\n\tStash(stashRegistry[_sender]).dec_position(_amount);\n\tStash(stashRegistry[_receiver]).inc_position(_amount);\n\t/* decide whether to resolve gridlock */\n\t/* if (txQueue.length >= maxQueueLen) { */\n\t/*     resolve(); */\n\t/* } */\n\treturn txQueue.length;\n    }\n\n    function get_n_deficits() private returns(int) {\n\tint count = 0;\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    if (Stash(stashRegistry[stashNames[j]]).getPosition() < 0 ) { count++; }\n\t}\n\treturn count;\n    }\n\n    /* only can be called by regulator\n\n       To avoid the outermost while loop in the original algorithm,\n       the number of iteration is limited to @param steps\n       If the resolution fails one can always resume in the next transaction\n       (or function call) */\n    function resolve(int steps) onlyowner external returns(bool) {\n\tfor (int i = steps; i > 0; i--) {\n\t    for (uint j = 0; j < stashNames.length; j++) {\n\t\tif (Stash(stashRegistry[stashNames[j]]).getPosition() >= 0) { continue; }\n\t\tfor (uint k = 0; k < txQueue.length; k++) {\n\t\t    var tx = txQueue[k];\n\t\t    if (tx.sender != stashNames[j] && tx.state != TxState.Active) { continue; }\n\t\t    txQueue[k].state = TxState.Inactive;\n\t\t    Stash(stashRegistry[txQueue[k].sender]).inc_position(tx.amount);\n\t\t    Stash(stashRegistry[txQueue[k].receiver]).dec_position(tx.amount);\n\t\t    if (Stash(stashRegistry[txQueue[k].sender]).getPosition() >= 0) { break; }\n\t\t}\n\t    }\n\t}\n\tif (get_n_deficits() > 0) { return false; }\n\telse { return true; }\n    }\n    \n    function settle() onlyowner private returns(bool) {\n\tif (get_n_deficits() > 0) { throw; }\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    Stash stash = Stash(stashRegistry[stashNames[j]]);\n\t    int net_diff = stash.getPosition() - stash.getBalance();\n\t    if (net_diff > 0) {\n\t\tstash.credit(net_diff);\n\t    } else if (net_diff < 0) {\n\t\tstash.safe_debit(-net_diff);\n\t    }\n\t}\n\tfor (uint k = 0; k < txQueue.length; k++) {\n\t    txQueue[k].state = TxState.Active;\n\t    var tx = txQueue[k];\n\t    Stash(stashRegistry[tx.sender]).dec_position(tx.amount);\n\t    Stash(stashRegistry[tx.receiver]).inc_position(tx.amount);\n\t}\n    }\n/*     /\\* only can be called by regulator *\\/ */\n/*     function resolve(int steps) onlyowner external returns(bool) { */\n/* \tfor (uint i = steps; i > 0: i--) { */\n/* \t    for (uint j = 0; i < stashNames.length; j++) { */\n/* \t\tif (stashRegistry[stashNames[i]].getPosition < 0) { */\n/*     for (uint k = 0; k < txQueue.length; k++) { */\n/*     tx = txQueue[k]; */\n/*     if (txQueue[k].sender == stashNames[i] && txQueue[k].state == TxState.Active) { */\n/*     txQueue[k].state = TxState.Inactive; */\n/*     stashRegistry[txQueue[k].sender].inc_position(_amount); */\n/*     stashRegistry[txQueue[k].receiver].dec_position(_amount); */\n/*     if (stashRegistry[txQueue[k].sender] >= 0) { break; } */\n/* } */\n/* } */\n/* \t\t} */\n/* \t    } */\n/* \t} */\n\t\n/* \treturn finished; */\n/*     } */\n\n\n    /* @depolyment, @live:\n       privateFor = MAS and participating node */\n    function transfer(bytes32 _src, bytes32 _dest, int _amount) {\n    \tStash src = Stash(stashRegistry[_src]);\n\tStash dest = Stash(stashRegistry[_dest]);\n\tif (_src == ownedStash) {\n\t    src.safe_debit(_amount);\n\t} else {\n\t    src.debit(_amount);\n\t}\n\tdest.credit(_amount);\n    }\n\n    /* @depolyment:\n       privateFor == MAS and owner node\n       amount == 0\n       \n       @live:\n       privateFor == MAS and owner node */\n    function pledge(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.credit(_amount);\n    }\n\n    /* @live:\n       privateFor = MAS and owner node */\n    function redeem(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.safe_debit(_amount);\n    }\n\n    /* @live:\n       for stashes not owned by you this returns the net bilateral position */\n    function getStash(bytes32 _bankName) constant returns (int) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\treturn stash.getBalance();\n    }\n\n    function getQueueLength() public constant returns(uint) {\n        return txQueue.length;\n    }\n}\n\n\n/* Public contract for holding RefData */\n/* contract RefData is mortal { */\n    \n/*     struct transaction { */\n/* \tbool exists; */\n/* \tuint timestamp; */\n/* \tbool active; */\n/*     } */\n\n/*     struct Bank { */\n/* \tstring name; */\n/* \tbool authorized; */\n/* \tbool exists; */\n/* \taddress authorizedSender; */\n/*     } */\n\n/*     address public regulator; */\n    \n/*     mapping (bytes32 => transaction) public transactions; */\n    \n/*     mapping (address => Bank) public banks; */\n    \n/*     function addTransaction (bytes32 _transactionID) { */\n/*         transactions[_transactionID].exists=true; */\n/*         transactions[_transactionID].timestamp=block.timestamp; */\n/*         transactions[_transactionID].active=true; */\n/*     } */\n\n/*     function getTransactionExistance (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].exists); */\n/*     } */\n\n/*     function getTransactionState (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].blocked); */\n/*     } */\n\n/*     function getTransactionTimestamp (bytes32 _transactionID) public constant  */\n/* \treturns (uint) { */\n/*         return (transactions[_transactionID].timestamp); */\n/*     } */\n\n/*     function bankExist (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].exists); */\n/*     } */\n\n/*     function bankAuthorized (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].authorized); */\n/*     } */\n\n/*     function getBankSender (address _contract) public constant  */\n/* \treturns (address) { */\n/*         return (banks[_contract].authorizedSender); */\n/*     } */\n\n/*     function activate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=true; */\n/* \t} */\n/*     } */\n\n/*     function inactivate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=false; */\n/* \t} */\n/*     } */\n\n/*     function addBank (string _name, address _contract, address _sender) onlyowner { */\n/* \tbanks[_contract].name=_name; */\n/* \tbanks[_contract].exists=true; */\n/* \tbanks[_contract].authorized=true; */\n/* \tbanks[_contract].authorizedSender=_sender; */\n/*     } */\n\n/*     function blockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=false; */\n/*     } */\n\n/*     function unblockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=true; */\n/*     } */\n\n/* } */\n","language":"Solidity","languageVersion":"0.4.11","compilerVersion":"0.4.11","compilerOptions":"--combined-json bin,abi,userdoc,devdoc --add-std --optimize","abiDefinition":[{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"inputs":[],"payable":false,"type":"constructor"}],"userDoc":{"methods":{}},"developerDoc":{"methods":{}}}}}