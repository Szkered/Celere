{"/tmp/geth-compile-solidity695864503:Stash":{"code":"0x6060604052341561000c57fe5b60405160408061040d8339810160405280516020909101515b5b60008054600160a060020a03191633600160a060020a03161790555b6001829055600281905560038190555b50505b6103a9806100646000396000f300606060405236156100c25763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166304d4f62481146100c457806309218e91146100d957806312065fe0146100fb57806327d358011461011d57806341c0e1b51461013f5780635ce239501461015157806369c83743146101755780637398ab181461018a578063893d20e8146101ac5780638c1fdf82146101d8578063a08c5c2f146101ed578063abc7b72314610202578063b69ef8a814610217575bfe5b34156100cc57fe5b6100d7600435610239565b005b34156100e157fe5b6100e9610262565b60408051918252519081900360200190f35b341561010357fe5b6100e9610268565b60408051918252519081900360200190f35b341561012557fe5b6100e961026f565b60408051918252519081900360200190f35b341561014757fe5b6100d7610275565b005b341561015957fe5b61016161029d565b604080519115158252519081900360200190f35b341561017d57fe5b6100d76004356102a9565b005b341561019257fe5b6100e96102d3565b60408051918252519081900360200190f35b34156101b457fe5b6101bc6102da565b60408051600160a060020a039092168252519081900360200190f35b34156101e057fe5b6100d76004356102ea565b005b34156101f557fe5b6100d7600435610324565b005b341561020a57fe5b6100d760043561034e565b005b341561021f57fe5b6100e9610377565b60408051918252519081900360200190f35b60005433600160a060020a039081169116146102555760006000fd5b60028054820190555b5b50565b60035481565b6002545b90565b60015481565b60005433600160a060020a039081169116141561029a57600054600160a060020a0316ff5b5b565b60035460009012155b90565b60005433600160a060020a039081169116146102c55760006000fd5b6002805482900390555b5b50565b6003545b90565b600054600160a060020a03165b90565b60005433600160a060020a039081169116146103065760006000fd5b6002548113156102c55760006000fd5b6002805482900390555b5b50565b60005433600160a060020a039081169116146103405760006000fd5b6003805482900390555b5b50565b60005433600160a060020a0390811691161461036a5760006000fd5b60038054820190555b5b50565b600254815600a165627a7a723058203c46ab3eeab5accfe73a84bee04735a9418471a768ff4cab9d66e8219a25707d0029","info":{"source":"/* pragma solidity ^0.4.2; */\n\ncontract owned{\n  address owner;\n  \n  function owned() {\n    owner = msg.sender;\n  }\n  \n  modifier onlyowner() {\n      if(msg.sender!=owner) throw; _;\n  }\n\n  function getOwner() constant returns (address) {\n      return owner;\n  }\n\n}\n\ncontract mortal is owned {\n  function kill() {\n    if (msg.sender == owner) suicide(owner); \n  }\n}\n\n/* To be deploy by PaymentAgent, so that no human has owner access */\ncontract Stash is mortal {\n    bytes32 public bankName;\n    int public balance;\n    int public position;\n\n    function Stash(bytes32 _bankName, int _balance) {\n\tbankName = _bankName;\n\tbalance = _balance;\n\tposition = _balance;\n    }\n\n    function credit(int _crAmt) onlyowner {\n\tbalance += _crAmt;\n    }\n\n    function debit(int _dAmt) onlyowner {\n\tbalance -= _dAmt;\n    }\n\n    function safe_debit(int _dAmt) onlyowner {\n\tif (_dAmt > balance) throw;\n\tbalance -= _dAmt;\n    }\n\n    function inc_position(int amt) onlyowner {\n\tposition += amt;\n    }\n\n    function dec_position(int amt) onlyowner {\n\tposition -= amt;\n    }\n\n    function getBalance() constant returns (int) {\n    \treturn balance;\n    }\n\n    function getPosition() constant returns (int) {\n    \treturn position;\n    }\n\n    function isSolvent() constant returns (bool) {\n    \treturn position >= 0;\n    }\n}\n\n\n/* To be deploy by regulator, so that regulator has owner access */\ncontract TransactionAgent is mortal {\n    bytes32 private ownedStash;\n    bytes32[] stashNames;\n    mapping (bytes32 => address) public stashRegistry;\n    bool resolving; \t\t/* true when resolving gridlock */\n    uint maxQueueLen;           /* queue depth trigger */\n\n    enum TxState { Active, Inactive, Locked }\n    \n    struct Tx {\n        bytes32 txRef; \n        bytes32 sender;\n        bytes32 receiver;\n        int amount;\n\tTxState state;\n    }\n\n    Tx[] public txQueue; /* 0-indexed array */\n\n    modifier isInvoled(bytes32 _sender, bytes32 _receiver) {\n\tif(ownedStash == _sender || ownedStash == _receiver) _;\n    }\n\n    modifier isPositive(int _amount) { if (_amount < 0 ) throw;_; }\n\n    function TransactionAgent(uint _maxQueueLen) {\n\towner = msg.sender;\n\townedStash = \"\";\n\tmaxQueueLen = _maxQueueLen;\n    }\n\n    function changeOwner(address _newOwner) onlyowner {\n\towner = _newOwner;\n    }\n\n    /* @deployment:\n       privateFor = everyone */\n    function createStash(bytes32 _bankName) onlyowner {\n\tstashRegistry[_bankName] = new Stash(_bankName, 0);\n\tstashNames.push(_bankName);\n    }\n\n    /* @deployment:\n       privateFor = everyone\n\n       register an existing stash */\n    function registerStash(bytes32 _bankName, address _addr) onlyowner {\n\tstashRegistry[_bankName] = _addr;\n\tstashNames.push(_bankName);\n    }\n    \n    /* @depolyment:\n       privateFor = MAS and owner node */\n    function markStash(bytes32 _bankName) onlyowner {\n\townedStash = _bankName;\n    }\n\n    /* @live:\n       privateFor = MAS and participating node */\n    function submitTx(bytes32 _txRef, bytes32 _sender, bytes32 _receiver, int _amount)\n\tisPositive(_amount) isInvoled(_sender, _receiver) external returns(uint) {\n\ttxQueue.length++;\n\ttxQueue[txQueue.length-1].txRef = _txRef;\n\ttxQueue[txQueue.length-1].sender = _sender;\n\ttxQueue[txQueue.length-1].receiver = _receiver;\n\ttxQueue[txQueue.length-1].amount = _amount;\n\ttxQueue[txQueue.length-1].state = TxState.Active;\n\t/* update position */\n\t/* Stash sender = Stash(stashRegistry[_sender]).dec; */\n\tStash(stashRegistry[_sender]).dec_position(_amount);\n\tStash(stashRegistry[_receiver]).inc_position(_amount);\n\t/* decide whether to resolve gridlock */\n\t/* if (txQueue.length >= maxQueueLen) { */\n\t/*     resolve(); */\n\t/* } */\n\treturn txQueue.length;\n    }\n\n    function get_n_deficits() private returns(int) {\n\tint count = 0;\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    if (Stash(stashRegistry[stashNames[j]]).getPosition() < 0 ) { count++; }\n\t}\n\treturn count;\n    }\n\n    /* only can be called by regulator\n\n       To avoid the outermost while loop in the original algorithm,\n       the number of iteration is limited to @param steps\n       If the resolution fails one can always resume in the next transaction\n       (or function call) */\n    function resolve(int steps) onlyowner external returns(bool) {\n\tfor (int i = steps; i > 0; i--) {\n\t    for (uint j = 0; j < stashNames.length; j++) {\n\t\tif (Stash(stashRegistry[stashNames[j]]).getPosition() >= 0) { continue; }\n\t\tfor (uint k = 0; k < txQueue.length; k++) {\n\t\t    var tx = txQueue[k];\n\t\t    if (tx.sender != stashNames[j] && tx.state != TxState.Active) { continue; }\n\t\t    txQueue[k].state = TxState.Inactive;\n\t\t    Stash(stashRegistry[txQueue[k].sender]).inc_position(tx.amount);\n\t\t    Stash(stashRegistry[txQueue[k].receiver]).dec_position(tx.amount);\n\t\t    if (stashRegistry[txQueue[k].sender] >= 0) { break; }\n\t\t}\n\t    }\n\t}\n\tif (get_n_deficits() > 0) { return false; }\n\telse { return true; }\n    }\n    \n    function settle() onlyowner private returns(bool) {\n\tif (get_n_deficits() > 0) { throw; }\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    Stash stash = Stash(stashRegistry[stashNames[j]]);\n\t    int net_diff = stash.getPosition() - stash.getBalance();\n\t    if (net_diff > 0) {\n\t\tstash.credit(net_diff);\n\t    } else if (net_diff < 0) {\n\t\tstash.safe_debit(-net_diff);\n\t    }\n\t}\n\tfor (uint k = 0; k < txQueue.length; k++) {\n\t    txQueue[k].state = TxState.Active;\n\t    var tx = txQueue[k];\n\t    Stash(stashRegistry[tx.sender]).dec_position(tx.amount);\n\t    Stash(stashRegistry[tx.receiver]).inc_position(tx.amount);\n\t}\n    }\n/*     /\\* only can be called by regulator *\\/ */\n/*     function resolve(int steps) onlyowner external returns(bool) { */\n/* \tfor (uint i = steps; i > 0: i--) { */\n/* \t    for (uint j = 0; i < stashNames.length; j++) { */\n/* \t\tif (stashRegistry[stashNames[i]].getPosition < 0) { */\n/*     for (uint k = 0; k < txQueue.length; k++) { */\n/*     tx = txQueue[k]; */\n/*     if (txQueue[k].sender == stashNames[i] && txQueue[k].state == TxState.Active) { */\n/*     txQueue[k].state = TxState.Inactive; */\n/*     stashRegistry[txQueue[k].sender].inc_position(_amount); */\n/*     stashRegistry[txQueue[k].receiver].dec_position(_amount); */\n/*     if (stashRegistry[txQueue[k].sender] >= 0) { break; } */\n/* } */\n/* } */\n/* \t\t} */\n/* \t    } */\n/* \t} */\n\t\n/* \treturn finished; */\n/*     } */\n\n\n    /* @depolyment, @live:\n       privateFor = MAS and participating node */\n    function transfer(bytes32 _src, bytes32 _dest, int _amount) {\n    \tStash src = Stash(stashRegistry[_src]);\n\tStash dest = Stash(stashRegistry[_dest]);\n\tif (_src == ownedStash) {\n\t    src.safe_debit(_amount);\n\t} else {\n\t    src.debit(_amount);\n\t}\n\tdest.credit(_amount);\n    }\n\n    /* @depolyment:\n       privateFor == MAS and owner node\n       amount == 0\n       \n       @live:\n       privateFor == MAS and owner node */\n    function pledge(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.credit(_amount);\n    }\n\n    /* @live:\n       privateFor = MAS and owner node */\n    function redeem(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.safe_debit(_amount);\n    }\n\n    /* @live:\n       for stashes not owned by you this returns the net bilateral position */\n    function getStash(bytes32 _bankName) constant returns (int) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\treturn stash.getBalance();\n    }\n\n    function getQueueLength() public constant returns(uint) {\n        return txQueue.length;\n    }\n}\n\n\n/* Public contract for holding RefData */\n/* contract RefData is mortal { */\n    \n/*     struct transaction { */\n/* \tbool exists; */\n/* \tuint timestamp; */\n/* \tbool active; */\n/*     } */\n\n/*     struct Bank { */\n/* \tstring name; */\n/* \tbool authorized; */\n/* \tbool exists; */\n/* \taddress authorizedSender; */\n/*     } */\n\n/*     address public regulator; */\n    \n/*     mapping (bytes32 => transaction) public transactions; */\n    \n/*     mapping (address => Bank) public banks; */\n    \n/*     function addTransaction (bytes32 _transactionID) { */\n/*         transactions[_transactionID].exists=true; */\n/*         transactions[_transactionID].timestamp=block.timestamp; */\n/*         transactions[_transactionID].active=true; */\n/*     } */\n\n/*     function getTransactionExistance (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].exists); */\n/*     } */\n\n/*     function getTransactionState (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].blocked); */\n/*     } */\n\n/*     function getTransactionTimestamp (bytes32 _transactionID) public constant  */\n/* \treturns (uint) { */\n/*         return (transactions[_transactionID].timestamp); */\n/*     } */\n\n/*     function bankExist (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].exists); */\n/*     } */\n\n/*     function bankAuthorized (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].authorized); */\n/*     } */\n\n/*     function getBankSender (address _contract) public constant  */\n/* \treturns (address) { */\n/*         return (banks[_contract].authorizedSender); */\n/*     } */\n\n/*     function activate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=true; */\n/* \t} */\n/*     } */\n\n/*     function inactivate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=false; */\n/* \t} */\n/*     } */\n\n/*     function addBank (string _name, address _contract, address _sender) onlyowner { */\n/* \tbanks[_contract].name=_name; */\n/* \tbanks[_contract].exists=true; */\n/* \tbanks[_contract].authorized=true; */\n/* \tbanks[_contract].authorizedSender=_sender; */\n/*     } */\n\n/*     function blockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=false; */\n/*     } */\n\n/*     function unblockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=true; */\n/*     } */\n\n/* } */\n","language":"Solidity","languageVersion":"0.4.11","compilerVersion":"0.4.11","compilerOptions":"--combined-json bin,abi,userdoc,devdoc --add-std --optimize","abiDefinition":[{"constant":false,"inputs":[{"name":"_crAmt","type":"int256"}],"name":"credit","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"position","outputs":[{"name":"","type":"int256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getBalance","outputs":[{"name":"","type":"int256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"bankName","outputs":[{"name":"","type":"bytes32"}],"payable":false,"type":"function"},{"constant":false,"inputs":[],"name":"kill","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"isSolvent","outputs":[{"name":"","type":"bool"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_dAmt","type":"int256"}],"name":"debit","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getPosition","outputs":[{"name":"","type":"int256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_dAmt","type":"int256"}],"name":"safe_debit","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"amt","type":"int256"}],"name":"dec_position","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"amt","type":"int256"}],"name":"inc_position","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"balance","outputs":[{"name":"","type":"int256"}],"payable":false,"type":"function"},{"inputs":[{"name":"_bankName","type":"bytes32"},{"name":"_balance","type":"int256"}],"payable":false,"type":"constructor"}],"userDoc":{"methods":{}},"developerDoc":{"methods":{}}}},"/tmp/geth-compile-solidity695864503:TransactionAgent":{"code":"0x6060604052341561000c57fe5b60405160208061140a83398101604052515b5b60008054600160a060020a03191633600160a060020a03161790555b60008054600160a060020a03191633600160a060020a031617815560015560058190555b505b61139a806100706000396000f300606060405236156100bf5763ffffffff60e060020a60003504166301810b1881146100c15780632a5b1c70146100e85780632ae6a3b21461011657806341c0e1b51461013b57806350cdb4b11461014d5780637768149014610168578063893d20e81461017d5780639cb5d0dc146101a9578063a6f9dae1146101be578063b721e118146101dc578063b8f77005146101f4578063be6554dc14610216578063cd193fa51461022e578063fb6cb61f14610284578063ff88b6a6146102b3575bfe5b34156100c957fe5b6100d46004356102d4565b604080519115158252519081900360200190f35b34156100f057fe5b610104600435602435604435606435610688565b60408051918252519081900360200190f35b341561011e57fe5b6101046004356108ba565b60408051918252519081900360200190f35b341561014357fe5b61014b610944565b005b341561015557fe5b61014b60043560243560443561096c565b005b341561017057fe5b61014b600435610aac565b005b341561018557fe5b61018d610ad2565b60408051600160a060020a039092168252519081900360200190f35b34156101b157fe5b61014b600435610ae2565b005b34156101c657fe5b61014b600160a060020a0360043516610b8a565b005b34156101e457fe5b61014b600435602435610bd3565b005b34156101fc57fe5b610104610c54565b60408051918252519081900360200190f35b341561021e57fe5b61014b600435602435610c5b565b005b341561023657fe5b610241600435610cdc565b6040805186815260208101869052908101849052606081018390526080810182600281111561026c57fe5b60ff1681526020019550505050505060405180910390f35b341561028c57fe5b61018d600435610d20565b60408051600160a060020a039092168252519081900360200190f35b34156102bb57fe5b61014b600435600160a060020a0360243516610d3b565b005b60008054819081908190819033600160a060020a039081169116146102f95760006000fd5b8593505b600084131561065f57600092505b6002548310156106525760006003600060028681548110151561032a57fe5b906000526020600020900160005b5054815260208082019290925260409081016000908120548251840182905282517f7398ab180000000000000000000000000000000000000000000000000000000081529251600160a060020a0390911693637398ab1893600480820194929392918390030190829087803b15156103ac57fe5b6102c65a03f115156103ba57fe5b5050604051519190911290506103cf57610646565b600091505b6006548210156106465760068054839081106103ec57fe5b906000526020600020906005020160005b50905060028381548110151561040f57fe5b906000526020600020900160005b5054600182015414801590610446575060005b600482015460ff16600281111561044357fe5b14155b156104505761063a565b600160068381548110151561046157fe5b906000526020600020906005020160005b50600401805460ff1916600183600281111561048a57fe5b0217905550600360006006848154811015156104a257fe5b906000526020600020906005020160005b5060010154815260208101919091526040908101600090812054600384015483517fabc7b72300000000000000000000000000000000000000000000000000000000815260048101919091529251600160a060020a039091169263abc7b72392602480830193919282900301818387803b151561052c57fe5b6102c65a03f1151561053a57fe5b5050506003600060068481548110151561055057fe5b906000526020600020906005020160005b5060020154815260208101919091526040908101600090812054600384015483517fa08c5c2f00000000000000000000000000000000000000000000000000000000815260048101919091529251600160a060020a039091169263a08c5c2f92602480830193919282900301818387803b15156105da57fe5b6102c65a03f115156105e857fe5b50505060006003600060068581548110151561060057fe5b906000526020600020906005020160005b50600101548152602081019190915260400160002054600160a060020a03161061063a57610646565b5b6001909101906103d4565b5b60019092019161030b565b5b600019909301926102fd565b6000610669610db6565b1315610678576000945061067d565b600194505b5b5b50505050919050565b600081600081121561069a5760006000fd5b600154859085908214806106af575060015481145b156108ac5760068054906106c69060018301610e93565b506006805489919060001981019081106106dc57fe5b906000526020600020906005020160005b505560068054889190600019810190811061070457fe5b906000526020600020906005020160005b506001015560068054879190600019810190811061072f57fe5b906000526020600020906005020160005b506002015560068054869190600019810190811061075a57fe5b906000526020600020906005020160005b50600301556006805460009190600019810190811061078657fe5b906000526020600020906005020160005b50600401805460ff191660018360028111156107af57fe5b02179055506000878152600360205260408082205481517fa08c5c2f000000000000000000000000000000000000000000000000000000008152600481018990529151600160a060020a039091169263a08c5c2f926024808201939182900301818387803b151561081c57fe5b6102c65a03f1151561082a57fe5b5050506000868152600360205260408082205481517fabc7b723000000000000000000000000000000000000000000000000000000008152600481018990529151600160a060020a039091169263abc7b723926024808201939182900301818387803b151561089557fe5b6102c65a03f115156108a357fe5b50506006549450505b5b5b50505b50949350505050565b6000818152600360209081526040808320548151830184905281517f12065fe00000000000000000000000000000000000000000000000000000000081529151600160a060020a039091169283926312065fe0926004808301939282900301818887803b151561092657fe5b6102c65a03f1151561093457fe5b5050604051519250505b50919050565b60005433600160a060020a039081169116141561096957600054600160a060020a0316ff5b5b565b60008381526003602052604080822054848352912054600154600160a060020a0392831692909116908514156109f75781600160a060020a0316638c1fdf82846040518263ffffffff1660e060020a02815260040180828152602001915050600060405180830381600087803b15156109e157fe5b6102c65a03f115156109ef57fe5b505050610a4e565b81600160a060020a03166369c83743846040518263ffffffff1660e060020a02815260040180828152602001915050600060405180830381600087803b1515610a3c57fe5b6102c65a03f11515610a4a57fe5b5050505b80600160a060020a03166304d4f624846040518263ffffffff1660e060020a02815260040180828152602001915050600060405180830381600087803b1515610a9357fe5b6102c65a03f11515610aa157fe5b5050505b5050505050565b60005433600160a060020a03908116911614610ac85760006000fd5b60018190555b5b50565b600054600160a060020a03165b90565b60005433600160a060020a03908116911614610afe5760006000fd5b806000610b09610ec5565b9182526020820152604080519182900301906000f0801515610b2757fe5b6000828152600360205260409020805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790556002805460018101610b728382610ed5565b916000526020600020900160005b50829055505b5b50565b60005433600160a060020a03908116911614610ba65760006000fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790555b5b50565b6000828152600360205260408082205481517f04d4f624000000000000000000000000000000000000000000000000000000008152600481018590529151600160a060020a039091169283926304d4f624926024808301939282900301818387803b1515610c3d57fe5b6102c65a03f11515610c4b57fe5b5050505b505050565b6006545b90565b6000828152600360205260408082205481517f8c1fdf82000000000000000000000000000000000000000000000000000000008152600481018590529151600160a060020a03909116928392638c1fdf82926024808301939282900301818387803b1515610c3d57fe5b6102c65a03f11515610c4b57fe5b5050505b505050565b6006805482908110610cea57fe5b906000526020600020906005020160005b5080546001820154600283015460038401546004909401549294509092909160ff1685565b600360205260009081526040902054600160a060020a031681565b60005433600160a060020a03908116911614610d575760006000fd5b6000828152600360205260409020805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790556002805460018101610d9d8382610ed5565b916000526020600020900160005b50839055505b5b5050565b600080805b600254811015610e8a57600060036000600284815481101515610dda57fe5b906000526020600020900160005b5054815260208082019290925260409081016000908120548251840182905282517f7398ab180000000000000000000000000000000000000000000000000000000081529251600160a060020a0390911693637398ab1893600480820194929392918390030190829087803b1515610e5c57fe5b6102c65a03f11515610e6a57fe5b505050604051805190501215610e81576001909101905b5b600101610dbb565b8192505b505090565b815481835581811511610c4f57600502816005028360005260206000209182019101610c4f9190610eff565b5b505050565b60405161040d80610f6283390190565b815481835581811511610c4f57600083815260209020610c4f918101908301610f40565b5b505050565b610adf91905b80821115610f395760008082556001820181905560028201819055600382015560048101805460ff19169055600501610f05565b5090565b90565b610adf91905b80821115610f395760008155600101610f46565b5090565b9056006060604052341561000c57fe5b60405160408061040d8339810160405280516020909101515b5b60008054600160a060020a03191633600160a060020a03161790555b6001829055600281905560038190555b50505b6103a9806100646000396000f300606060405236156100c25763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166304d4f62481146100c457806309218e91146100d957806312065fe0146100fb57806327d358011461011d57806341c0e1b51461013f5780635ce239501461015157806369c83743146101755780637398ab181461018a578063893d20e8146101ac5780638c1fdf82146101d8578063a08c5c2f146101ed578063abc7b72314610202578063b69ef8a814610217575bfe5b34156100cc57fe5b6100d7600435610239565b005b34156100e157fe5b6100e9610262565b60408051918252519081900360200190f35b341561010357fe5b6100e9610268565b60408051918252519081900360200190f35b341561012557fe5b6100e961026f565b60408051918252519081900360200190f35b341561014757fe5b6100d7610275565b005b341561015957fe5b61016161029d565b604080519115158252519081900360200190f35b341561017d57fe5b6100d76004356102a9565b005b341561019257fe5b6100e96102d3565b60408051918252519081900360200190f35b34156101b457fe5b6101bc6102da565b60408051600160a060020a039092168252519081900360200190f35b34156101e057fe5b6100d76004356102ea565b005b34156101f557fe5b6100d7600435610324565b005b341561020a57fe5b6100d760043561034e565b005b341561021f57fe5b6100e9610377565b60408051918252519081900360200190f35b60005433600160a060020a039081169116146102555760006000fd5b60028054820190555b5b50565b60035481565b6002545b90565b60015481565b60005433600160a060020a039081169116141561029a57600054600160a060020a0316ff5b5b565b60035460009012155b90565b60005433600160a060020a039081169116146102c55760006000fd5b6002805482900390555b5b50565b6003545b90565b600054600160a060020a03165b90565b60005433600160a060020a039081169116146103065760006000fd5b6002548113156102c55760006000fd5b6002805482900390555b5b50565b60005433600160a060020a039081169116146103405760006000fd5b6003805482900390555b5b50565b60005433600160a060020a0390811691161461036a5760006000fd5b60038054820190555b5b50565b600254815600a165627a7a723058203c46ab3eeab5accfe73a84bee04735a9418471a768ff4cab9d66e8219a25707d0029a165627a7a723058205c1f25a7a8d4594bdddcee955a9714cc10abbf4cbb3ae1136528a368beb178070029","info":{"source":"/* pragma solidity ^0.4.2; */\n\ncontract owned{\n  address owner;\n  \n  function owned() {\n    owner = msg.sender;\n  }\n  \n  modifier onlyowner() {\n      if(msg.sender!=owner) throw; _;\n  }\n\n  function getOwner() constant returns (address) {\n      return owner;\n  }\n\n}\n\ncontract mortal is owned {\n  function kill() {\n    if (msg.sender == owner) suicide(owner); \n  }\n}\n\n/* To be deploy by PaymentAgent, so that no human has owner access */\ncontract Stash is mortal {\n    bytes32 public bankName;\n    int public balance;\n    int public position;\n\n    function Stash(bytes32 _bankName, int _balance) {\n\tbankName = _bankName;\n\tbalance = _balance;\n\tposition = _balance;\n    }\n\n    function credit(int _crAmt) onlyowner {\n\tbalance += _crAmt;\n    }\n\n    function debit(int _dAmt) onlyowner {\n\tbalance -= _dAmt;\n    }\n\n    function safe_debit(int _dAmt) onlyowner {\n\tif (_dAmt > balance) throw;\n\tbalance -= _dAmt;\n    }\n\n    function inc_position(int amt) onlyowner {\n\tposition += amt;\n    }\n\n    function dec_position(int amt) onlyowner {\n\tposition -= amt;\n    }\n\n    function getBalance() constant returns (int) {\n    \treturn balance;\n    }\n\n    function getPosition() constant returns (int) {\n    \treturn position;\n    }\n\n    function isSolvent() constant returns (bool) {\n    \treturn position >= 0;\n    }\n}\n\n\n/* To be deploy by regulator, so that regulator has owner access */\ncontract TransactionAgent is mortal {\n    bytes32 private ownedStash;\n    bytes32[] stashNames;\n    mapping (bytes32 => address) public stashRegistry;\n    bool resolving; \t\t/* true when resolving gridlock */\n    uint maxQueueLen;           /* queue depth trigger */\n\n    enum TxState { Active, Inactive, Locked }\n    \n    struct Tx {\n        bytes32 txRef; \n        bytes32 sender;\n        bytes32 receiver;\n        int amount;\n\tTxState state;\n    }\n\n    Tx[] public txQueue; /* 0-indexed array */\n\n    modifier isInvoled(bytes32 _sender, bytes32 _receiver) {\n\tif(ownedStash == _sender || ownedStash == _receiver) _;\n    }\n\n    modifier isPositive(int _amount) { if (_amount < 0 ) throw;_; }\n\n    function TransactionAgent(uint _maxQueueLen) {\n\towner = msg.sender;\n\townedStash = \"\";\n\tmaxQueueLen = _maxQueueLen;\n    }\n\n    function changeOwner(address _newOwner) onlyowner {\n\towner = _newOwner;\n    }\n\n    /* @deployment:\n       privateFor = everyone */\n    function createStash(bytes32 _bankName) onlyowner {\n\tstashRegistry[_bankName] = new Stash(_bankName, 0);\n\tstashNames.push(_bankName);\n    }\n\n    /* @deployment:\n       privateFor = everyone\n\n       register an existing stash */\n    function registerStash(bytes32 _bankName, address _addr) onlyowner {\n\tstashRegistry[_bankName] = _addr;\n\tstashNames.push(_bankName);\n    }\n    \n    /* @depolyment:\n       privateFor = MAS and owner node */\n    function markStash(bytes32 _bankName) onlyowner {\n\townedStash = _bankName;\n    }\n\n    /* @live:\n       privateFor = MAS and participating node */\n    function submitTx(bytes32 _txRef, bytes32 _sender, bytes32 _receiver, int _amount)\n\tisPositive(_amount) isInvoled(_sender, _receiver) external returns(uint) {\n\ttxQueue.length++;\n\ttxQueue[txQueue.length-1].txRef = _txRef;\n\ttxQueue[txQueue.length-1].sender = _sender;\n\ttxQueue[txQueue.length-1].receiver = _receiver;\n\ttxQueue[txQueue.length-1].amount = _amount;\n\ttxQueue[txQueue.length-1].state = TxState.Active;\n\t/* update position */\n\t/* Stash sender = Stash(stashRegistry[_sender]).dec; */\n\tStash(stashRegistry[_sender]).dec_position(_amount);\n\tStash(stashRegistry[_receiver]).inc_position(_amount);\n\t/* decide whether to resolve gridlock */\n\t/* if (txQueue.length >= maxQueueLen) { */\n\t/*     resolve(); */\n\t/* } */\n\treturn txQueue.length;\n    }\n\n    function get_n_deficits() private returns(int) {\n\tint count = 0;\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    if (Stash(stashRegistry[stashNames[j]]).getPosition() < 0 ) { count++; }\n\t}\n\treturn count;\n    }\n\n    /* only can be called by regulator\n\n       To avoid the outermost while loop in the original algorithm,\n       the number of iteration is limited to @param steps\n       If the resolution fails one can always resume in the next transaction\n       (or function call) */\n    function resolve(int steps) onlyowner external returns(bool) {\n\tfor (int i = steps; i > 0; i--) {\n\t    for (uint j = 0; j < stashNames.length; j++) {\n\t\tif (Stash(stashRegistry[stashNames[j]]).getPosition() >= 0) { continue; }\n\t\tfor (uint k = 0; k < txQueue.length; k++) {\n\t\t    var tx = txQueue[k];\n\t\t    if (tx.sender != stashNames[j] && tx.state != TxState.Active) { continue; }\n\t\t    txQueue[k].state = TxState.Inactive;\n\t\t    Stash(stashRegistry[txQueue[k].sender]).inc_position(tx.amount);\n\t\t    Stash(stashRegistry[txQueue[k].receiver]).dec_position(tx.amount);\n\t\t    if (stashRegistry[txQueue[k].sender] >= 0) { break; }\n\t\t}\n\t    }\n\t}\n\tif (get_n_deficits() > 0) { return false; }\n\telse { return true; }\n    }\n    \n    function settle() onlyowner private returns(bool) {\n\tif (get_n_deficits() > 0) { throw; }\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    Stash stash = Stash(stashRegistry[stashNames[j]]);\n\t    int net_diff = stash.getPosition() - stash.getBalance();\n\t    if (net_diff > 0) {\n\t\tstash.credit(net_diff);\n\t    } else if (net_diff < 0) {\n\t\tstash.safe_debit(-net_diff);\n\t    }\n\t}\n\tfor (uint k = 0; k < txQueue.length; k++) {\n\t    txQueue[k].state = TxState.Active;\n\t    var tx = txQueue[k];\n\t    Stash(stashRegistry[tx.sender]).dec_position(tx.amount);\n\t    Stash(stashRegistry[tx.receiver]).inc_position(tx.amount);\n\t}\n    }\n/*     /\\* only can be called by regulator *\\/ */\n/*     function resolve(int steps) onlyowner external returns(bool) { */\n/* \tfor (uint i = steps; i > 0: i--) { */\n/* \t    for (uint j = 0; i < stashNames.length; j++) { */\n/* \t\tif (stashRegistry[stashNames[i]].getPosition < 0) { */\n/*     for (uint k = 0; k < txQueue.length; k++) { */\n/*     tx = txQueue[k]; */\n/*     if (txQueue[k].sender == stashNames[i] && txQueue[k].state == TxState.Active) { */\n/*     txQueue[k].state = TxState.Inactive; */\n/*     stashRegistry[txQueue[k].sender].inc_position(_amount); */\n/*     stashRegistry[txQueue[k].receiver].dec_position(_amount); */\n/*     if (stashRegistry[txQueue[k].sender] >= 0) { break; } */\n/* } */\n/* } */\n/* \t\t} */\n/* \t    } */\n/* \t} */\n\t\n/* \treturn finished; */\n/*     } */\n\n\n    /* @depolyment, @live:\n       privateFor = MAS and participating node */\n    function transfer(bytes32 _src, bytes32 _dest, int _amount) {\n    \tStash src = Stash(stashRegistry[_src]);\n\tStash dest = Stash(stashRegistry[_dest]);\n\tif (_src == ownedStash) {\n\t    src.safe_debit(_amount);\n\t} else {\n\t    src.debit(_amount);\n\t}\n\tdest.credit(_amount);\n    }\n\n    /* @depolyment:\n       privateFor == MAS and owner node\n       amount == 0\n       \n       @live:\n       privateFor == MAS and owner node */\n    function pledge(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.credit(_amount);\n    }\n\n    /* @live:\n       privateFor = MAS and owner node */\n    function redeem(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.safe_debit(_amount);\n    }\n\n    /* @live:\n       for stashes not owned by you this returns the net bilateral position */\n    function getStash(bytes32 _bankName) constant returns (int) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\treturn stash.getBalance();\n    }\n\n    function getQueueLength() public constant returns(uint) {\n        return txQueue.length;\n    }\n}\n\n\n/* Public contract for holding RefData */\n/* contract RefData is mortal { */\n    \n/*     struct transaction { */\n/* \tbool exists; */\n/* \tuint timestamp; */\n/* \tbool active; */\n/*     } */\n\n/*     struct Bank { */\n/* \tstring name; */\n/* \tbool authorized; */\n/* \tbool exists; */\n/* \taddress authorizedSender; */\n/*     } */\n\n/*     address public regulator; */\n    \n/*     mapping (bytes32 => transaction) public transactions; */\n    \n/*     mapping (address => Bank) public banks; */\n    \n/*     function addTransaction (bytes32 _transactionID) { */\n/*         transactions[_transactionID].exists=true; */\n/*         transactions[_transactionID].timestamp=block.timestamp; */\n/*         transactions[_transactionID].active=true; */\n/*     } */\n\n/*     function getTransactionExistance (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].exists); */\n/*     } */\n\n/*     function getTransactionState (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].blocked); */\n/*     } */\n\n/*     function getTransactionTimestamp (bytes32 _transactionID) public constant  */\n/* \treturns (uint) { */\n/*         return (transactions[_transactionID].timestamp); */\n/*     } */\n\n/*     function bankExist (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].exists); */\n/*     } */\n\n/*     function bankAuthorized (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].authorized); */\n/*     } */\n\n/*     function getBankSender (address _contract) public constant  */\n/* \treturns (address) { */\n/*         return (banks[_contract].authorizedSender); */\n/*     } */\n\n/*     function activate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=true; */\n/* \t} */\n/*     } */\n\n/*     function inactivate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=false; */\n/* \t} */\n/*     } */\n\n/*     function addBank (string _name, address _contract, address _sender) onlyowner { */\n/* \tbanks[_contract].name=_name; */\n/* \tbanks[_contract].exists=true; */\n/* \tbanks[_contract].authorized=true; */\n/* \tbanks[_contract].authorizedSender=_sender; */\n/*     } */\n\n/*     function blockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=false; */\n/*     } */\n\n/*     function unblockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=true; */\n/*     } */\n\n/* } */\n","language":"Solidity","languageVersion":"0.4.11","compilerVersion":"0.4.11","compilerOptions":"--combined-json bin,abi,userdoc,devdoc --add-std --optimize","abiDefinition":[{"constant":false,"inputs":[{"name":"steps","type":"int256"}],"name":"resolve","outputs":[{"name":"","type":"bool"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_txRef","type":"bytes32"},{"name":"_sender","type":"bytes32"},{"name":"_receiver","type":"bytes32"},{"name":"_amount","type":"int256"}],"name":"submitTx","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"_bankName","type":"bytes32"}],"name":"getStash","outputs":[{"name":"","type":"int256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[],"name":"kill","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_src","type":"bytes32"},{"name":"_dest","type":"bytes32"},{"name":"_amount","type":"int256"}],"name":"transfer","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_bankName","type":"bytes32"}],"name":"markStash","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_bankName","type":"bytes32"}],"name":"createStash","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_newOwner","type":"address"}],"name":"changeOwner","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_bankName","type":"bytes32"},{"name":"_amount","type":"int256"}],"name":"pledge","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getQueueLength","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_bankName","type":"bytes32"},{"name":"_amount","type":"int256"}],"name":"redeem","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"txQueue","outputs":[{"name":"txRef","type":"bytes32"},{"name":"sender","type":"bytes32"},{"name":"receiver","type":"bytes32"},{"name":"amount","type":"int256"},{"name":"state","type":"uint8"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"","type":"bytes32"}],"name":"stashRegistry","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_bankName","type":"bytes32"},{"name":"_addr","type":"address"}],"name":"registerStash","outputs":[],"payable":false,"type":"function"},{"inputs":[{"name":"_maxQueueLen","type":"uint256"}],"payable":false,"type":"constructor"}],"userDoc":{"methods":{}},"developerDoc":{"methods":{}}}},"/tmp/geth-compile-solidity695864503:mortal":{"code":"0x60606040525b60008054600160a060020a03191633600160a060020a03161790555b5b610112806100316000396000f300606060405263ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166341c0e1b581146043578063893d20e8146052575bfe5b3415604a57fe5b60506088565b005b3415605957fe5b605f60c9565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b6000543373ffffffffffffffffffffffffffffffffffffffff9081169116141560c65760005473ffffffffffffffffffffffffffffffffffffffff16ff5b5b565b60005473ffffffffffffffffffffffffffffffffffffffff165b905600a165627a7a723058207165c69c1f9ce2035f9b0fd687e3c184abb8b692da6182645825fa28169d32550029","info":{"source":"/* pragma solidity ^0.4.2; */\n\ncontract owned{\n  address owner;\n  \n  function owned() {\n    owner = msg.sender;\n  }\n  \n  modifier onlyowner() {\n      if(msg.sender!=owner) throw; _;\n  }\n\n  function getOwner() constant returns (address) {\n      return owner;\n  }\n\n}\n\ncontract mortal is owned {\n  function kill() {\n    if (msg.sender == owner) suicide(owner); \n  }\n}\n\n/* To be deploy by PaymentAgent, so that no human has owner access */\ncontract Stash is mortal {\n    bytes32 public bankName;\n    int public balance;\n    int public position;\n\n    function Stash(bytes32 _bankName, int _balance) {\n\tbankName = _bankName;\n\tbalance = _balance;\n\tposition = _balance;\n    }\n\n    function credit(int _crAmt) onlyowner {\n\tbalance += _crAmt;\n    }\n\n    function debit(int _dAmt) onlyowner {\n\tbalance -= _dAmt;\n    }\n\n    function safe_debit(int _dAmt) onlyowner {\n\tif (_dAmt > balance) throw;\n\tbalance -= _dAmt;\n    }\n\n    function inc_position(int amt) onlyowner {\n\tposition += amt;\n    }\n\n    function dec_position(int amt) onlyowner {\n\tposition -= amt;\n    }\n\n    function getBalance() constant returns (int) {\n    \treturn balance;\n    }\n\n    function getPosition() constant returns (int) {\n    \treturn position;\n    }\n\n    function isSolvent() constant returns (bool) {\n    \treturn position >= 0;\n    }\n}\n\n\n/* To be deploy by regulator, so that regulator has owner access */\ncontract TransactionAgent is mortal {\n    bytes32 private ownedStash;\n    bytes32[] stashNames;\n    mapping (bytes32 => address) public stashRegistry;\n    bool resolving; \t\t/* true when resolving gridlock */\n    uint maxQueueLen;           /* queue depth trigger */\n\n    enum TxState { Active, Inactive, Locked }\n    \n    struct Tx {\n        bytes32 txRef; \n        bytes32 sender;\n        bytes32 receiver;\n        int amount;\n\tTxState state;\n    }\n\n    Tx[] public txQueue; /* 0-indexed array */\n\n    modifier isInvoled(bytes32 _sender, bytes32 _receiver) {\n\tif(ownedStash == _sender || ownedStash == _receiver) _;\n    }\n\n    modifier isPositive(int _amount) { if (_amount < 0 ) throw;_; }\n\n    function TransactionAgent(uint _maxQueueLen) {\n\towner = msg.sender;\n\townedStash = \"\";\n\tmaxQueueLen = _maxQueueLen;\n    }\n\n    function changeOwner(address _newOwner) onlyowner {\n\towner = _newOwner;\n    }\n\n    /* @deployment:\n       privateFor = everyone */\n    function createStash(bytes32 _bankName) onlyowner {\n\tstashRegistry[_bankName] = new Stash(_bankName, 0);\n\tstashNames.push(_bankName);\n    }\n\n    /* @deployment:\n       privateFor = everyone\n\n       register an existing stash */\n    function registerStash(bytes32 _bankName, address _addr) onlyowner {\n\tstashRegistry[_bankName] = _addr;\n\tstashNames.push(_bankName);\n    }\n    \n    /* @depolyment:\n       privateFor = MAS and owner node */\n    function markStash(bytes32 _bankName) onlyowner {\n\townedStash = _bankName;\n    }\n\n    /* @live:\n       privateFor = MAS and participating node */\n    function submitTx(bytes32 _txRef, bytes32 _sender, bytes32 _receiver, int _amount)\n\tisPositive(_amount) isInvoled(_sender, _receiver) external returns(uint) {\n\ttxQueue.length++;\n\ttxQueue[txQueue.length-1].txRef = _txRef;\n\ttxQueue[txQueue.length-1].sender = _sender;\n\ttxQueue[txQueue.length-1].receiver = _receiver;\n\ttxQueue[txQueue.length-1].amount = _amount;\n\ttxQueue[txQueue.length-1].state = TxState.Active;\n\t/* update position */\n\t/* Stash sender = Stash(stashRegistry[_sender]).dec; */\n\tStash(stashRegistry[_sender]).dec_position(_amount);\n\tStash(stashRegistry[_receiver]).inc_position(_amount);\n\t/* decide whether to resolve gridlock */\n\t/* if (txQueue.length >= maxQueueLen) { */\n\t/*     resolve(); */\n\t/* } */\n\treturn txQueue.length;\n    }\n\n    function get_n_deficits() private returns(int) {\n\tint count = 0;\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    if (Stash(stashRegistry[stashNames[j]]).getPosition() < 0 ) { count++; }\n\t}\n\treturn count;\n    }\n\n    /* only can be called by regulator\n\n       To avoid the outermost while loop in the original algorithm,\n       the number of iteration is limited to @param steps\n       If the resolution fails one can always resume in the next transaction\n       (or function call) */\n    function resolve(int steps) onlyowner external returns(bool) {\n\tfor (int i = steps; i > 0; i--) {\n\t    for (uint j = 0; j < stashNames.length; j++) {\n\t\tif (Stash(stashRegistry[stashNames[j]]).getPosition() >= 0) { continue; }\n\t\tfor (uint k = 0; k < txQueue.length; k++) {\n\t\t    var tx = txQueue[k];\n\t\t    if (tx.sender != stashNames[j] && tx.state != TxState.Active) { continue; }\n\t\t    txQueue[k].state = TxState.Inactive;\n\t\t    Stash(stashRegistry[txQueue[k].sender]).inc_position(tx.amount);\n\t\t    Stash(stashRegistry[txQueue[k].receiver]).dec_position(tx.amount);\n\t\t    if (stashRegistry[txQueue[k].sender] >= 0) { break; }\n\t\t}\n\t    }\n\t}\n\tif (get_n_deficits() > 0) { return false; }\n\telse { return true; }\n    }\n    \n    function settle() onlyowner private returns(bool) {\n\tif (get_n_deficits() > 0) { throw; }\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    Stash stash = Stash(stashRegistry[stashNames[j]]);\n\t    int net_diff = stash.getPosition() - stash.getBalance();\n\t    if (net_diff > 0) {\n\t\tstash.credit(net_diff);\n\t    } else if (net_diff < 0) {\n\t\tstash.safe_debit(-net_diff);\n\t    }\n\t}\n\tfor (uint k = 0; k < txQueue.length; k++) {\n\t    txQueue[k].state = TxState.Active;\n\t    var tx = txQueue[k];\n\t    Stash(stashRegistry[tx.sender]).dec_position(tx.amount);\n\t    Stash(stashRegistry[tx.receiver]).inc_position(tx.amount);\n\t}\n    }\n/*     /\\* only can be called by regulator *\\/ */\n/*     function resolve(int steps) onlyowner external returns(bool) { */\n/* \tfor (uint i = steps; i > 0: i--) { */\n/* \t    for (uint j = 0; i < stashNames.length; j++) { */\n/* \t\tif (stashRegistry[stashNames[i]].getPosition < 0) { */\n/*     for (uint k = 0; k < txQueue.length; k++) { */\n/*     tx = txQueue[k]; */\n/*     if (txQueue[k].sender == stashNames[i] && txQueue[k].state == TxState.Active) { */\n/*     txQueue[k].state = TxState.Inactive; */\n/*     stashRegistry[txQueue[k].sender].inc_position(_amount); */\n/*     stashRegistry[txQueue[k].receiver].dec_position(_amount); */\n/*     if (stashRegistry[txQueue[k].sender] >= 0) { break; } */\n/* } */\n/* } */\n/* \t\t} */\n/* \t    } */\n/* \t} */\n\t\n/* \treturn finished; */\n/*     } */\n\n\n    /* @depolyment, @live:\n       privateFor = MAS and participating node */\n    function transfer(bytes32 _src, bytes32 _dest, int _amount) {\n    \tStash src = Stash(stashRegistry[_src]);\n\tStash dest = Stash(stashRegistry[_dest]);\n\tif (_src == ownedStash) {\n\t    src.safe_debit(_amount);\n\t} else {\n\t    src.debit(_amount);\n\t}\n\tdest.credit(_amount);\n    }\n\n    /* @depolyment:\n       privateFor == MAS and owner node\n       amount == 0\n       \n       @live:\n       privateFor == MAS and owner node */\n    function pledge(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.credit(_amount);\n    }\n\n    /* @live:\n       privateFor = MAS and owner node */\n    function redeem(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.safe_debit(_amount);\n    }\n\n    /* @live:\n       for stashes not owned by you this returns the net bilateral position */\n    function getStash(bytes32 _bankName) constant returns (int) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\treturn stash.getBalance();\n    }\n\n    function getQueueLength() public constant returns(uint) {\n        return txQueue.length;\n    }\n}\n\n\n/* Public contract for holding RefData */\n/* contract RefData is mortal { */\n    \n/*     struct transaction { */\n/* \tbool exists; */\n/* \tuint timestamp; */\n/* \tbool active; */\n/*     } */\n\n/*     struct Bank { */\n/* \tstring name; */\n/* \tbool authorized; */\n/* \tbool exists; */\n/* \taddress authorizedSender; */\n/*     } */\n\n/*     address public regulator; */\n    \n/*     mapping (bytes32 => transaction) public transactions; */\n    \n/*     mapping (address => Bank) public banks; */\n    \n/*     function addTransaction (bytes32 _transactionID) { */\n/*         transactions[_transactionID].exists=true; */\n/*         transactions[_transactionID].timestamp=block.timestamp; */\n/*         transactions[_transactionID].active=true; */\n/*     } */\n\n/*     function getTransactionExistance (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].exists); */\n/*     } */\n\n/*     function getTransactionState (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].blocked); */\n/*     } */\n\n/*     function getTransactionTimestamp (bytes32 _transactionID) public constant  */\n/* \treturns (uint) { */\n/*         return (transactions[_transactionID].timestamp); */\n/*     } */\n\n/*     function bankExist (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].exists); */\n/*     } */\n\n/*     function bankAuthorized (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].authorized); */\n/*     } */\n\n/*     function getBankSender (address _contract) public constant  */\n/* \treturns (address) { */\n/*         return (banks[_contract].authorizedSender); */\n/*     } */\n\n/*     function activate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=true; */\n/* \t} */\n/*     } */\n\n/*     function inactivate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=false; */\n/* \t} */\n/*     } */\n\n/*     function addBank (string _name, address _contract, address _sender) onlyowner { */\n/* \tbanks[_contract].name=_name; */\n/* \tbanks[_contract].exists=true; */\n/* \tbanks[_contract].authorized=true; */\n/* \tbanks[_contract].authorizedSender=_sender; */\n/*     } */\n\n/*     function blockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=false; */\n/*     } */\n\n/*     function unblockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=true; */\n/*     } */\n\n/* } */\n","language":"Solidity","languageVersion":"0.4.11","compilerVersion":"0.4.11","compilerOptions":"--combined-json bin,abi,userdoc,devdoc --add-std --optimize","abiDefinition":[{"constant":false,"inputs":[],"name":"kill","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"}],"userDoc":{"methods":{}},"developerDoc":{"methods":{}}}},"/tmp/geth-compile-solidity695864503:owned":{"code":"0x6060604052341561000c57fe5b5b60008054600160a060020a03191633600160a060020a03161790555b5b60b8806100386000396000f300606060405263ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663893d20e881146039575bfe5b3415604057fe5b6046606f565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b60005473ffffffffffffffffffffffffffffffffffffffff165b905600a165627a7a7230582049bfe3ca7e88e368ece72e14e688f8f65cb4c1d4bf91557d3f89dfafde04a54e0029","info":{"source":"/* pragma solidity ^0.4.2; */\n\ncontract owned{\n  address owner;\n  \n  function owned() {\n    owner = msg.sender;\n  }\n  \n  modifier onlyowner() {\n      if(msg.sender!=owner) throw; _;\n  }\n\n  function getOwner() constant returns (address) {\n      return owner;\n  }\n\n}\n\ncontract mortal is owned {\n  function kill() {\n    if (msg.sender == owner) suicide(owner); \n  }\n}\n\n/* To be deploy by PaymentAgent, so that no human has owner access */\ncontract Stash is mortal {\n    bytes32 public bankName;\n    int public balance;\n    int public position;\n\n    function Stash(bytes32 _bankName, int _balance) {\n\tbankName = _bankName;\n\tbalance = _balance;\n\tposition = _balance;\n    }\n\n    function credit(int _crAmt) onlyowner {\n\tbalance += _crAmt;\n    }\n\n    function debit(int _dAmt) onlyowner {\n\tbalance -= _dAmt;\n    }\n\n    function safe_debit(int _dAmt) onlyowner {\n\tif (_dAmt > balance) throw;\n\tbalance -= _dAmt;\n    }\n\n    function inc_position(int amt) onlyowner {\n\tposition += amt;\n    }\n\n    function dec_position(int amt) onlyowner {\n\tposition -= amt;\n    }\n\n    function getBalance() constant returns (int) {\n    \treturn balance;\n    }\n\n    function getPosition() constant returns (int) {\n    \treturn position;\n    }\n\n    function isSolvent() constant returns (bool) {\n    \treturn position >= 0;\n    }\n}\n\n\n/* To be deploy by regulator, so that regulator has owner access */\ncontract TransactionAgent is mortal {\n    bytes32 private ownedStash;\n    bytes32[] stashNames;\n    mapping (bytes32 => address) public stashRegistry;\n    bool resolving; \t\t/* true when resolving gridlock */\n    uint maxQueueLen;           /* queue depth trigger */\n\n    enum TxState { Active, Inactive, Locked }\n    \n    struct Tx {\n        bytes32 txRef; \n        bytes32 sender;\n        bytes32 receiver;\n        int amount;\n\tTxState state;\n    }\n\n    Tx[] public txQueue; /* 0-indexed array */\n\n    modifier isInvoled(bytes32 _sender, bytes32 _receiver) {\n\tif(ownedStash == _sender || ownedStash == _receiver) _;\n    }\n\n    modifier isPositive(int _amount) { if (_amount < 0 ) throw;_; }\n\n    function TransactionAgent(uint _maxQueueLen) {\n\towner = msg.sender;\n\townedStash = \"\";\n\tmaxQueueLen = _maxQueueLen;\n    }\n\n    function changeOwner(address _newOwner) onlyowner {\n\towner = _newOwner;\n    }\n\n    /* @deployment:\n       privateFor = everyone */\n    function createStash(bytes32 _bankName) onlyowner {\n\tstashRegistry[_bankName] = new Stash(_bankName, 0);\n\tstashNames.push(_bankName);\n    }\n\n    /* @deployment:\n       privateFor = everyone\n\n       register an existing stash */\n    function registerStash(bytes32 _bankName, address _addr) onlyowner {\n\tstashRegistry[_bankName] = _addr;\n\tstashNames.push(_bankName);\n    }\n    \n    /* @depolyment:\n       privateFor = MAS and owner node */\n    function markStash(bytes32 _bankName) onlyowner {\n\townedStash = _bankName;\n    }\n\n    /* @live:\n       privateFor = MAS and participating node */\n    function submitTx(bytes32 _txRef, bytes32 _sender, bytes32 _receiver, int _amount)\n\tisPositive(_amount) isInvoled(_sender, _receiver) external returns(uint) {\n\ttxQueue.length++;\n\ttxQueue[txQueue.length-1].txRef = _txRef;\n\ttxQueue[txQueue.length-1].sender = _sender;\n\ttxQueue[txQueue.length-1].receiver = _receiver;\n\ttxQueue[txQueue.length-1].amount = _amount;\n\ttxQueue[txQueue.length-1].state = TxState.Active;\n\t/* update position */\n\t/* Stash sender = Stash(stashRegistry[_sender]).dec; */\n\tStash(stashRegistry[_sender]).dec_position(_amount);\n\tStash(stashRegistry[_receiver]).inc_position(_amount);\n\t/* decide whether to resolve gridlock */\n\t/* if (txQueue.length >= maxQueueLen) { */\n\t/*     resolve(); */\n\t/* } */\n\treturn txQueue.length;\n    }\n\n    function get_n_deficits() private returns(int) {\n\tint count = 0;\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    if (Stash(stashRegistry[stashNames[j]]).getPosition() < 0 ) { count++; }\n\t}\n\treturn count;\n    }\n\n    /* only can be called by regulator\n\n       To avoid the outermost while loop in the original algorithm,\n       the number of iteration is limited to @param steps\n       If the resolution fails one can always resume in the next transaction\n       (or function call) */\n    function resolve(int steps) onlyowner external returns(bool) {\n\tfor (int i = steps; i > 0; i--) {\n\t    for (uint j = 0; j < stashNames.length; j++) {\n\t\tif (Stash(stashRegistry[stashNames[j]]).getPosition() >= 0) { continue; }\n\t\tfor (uint k = 0; k < txQueue.length; k++) {\n\t\t    var tx = txQueue[k];\n\t\t    if (tx.sender != stashNames[j] && tx.state != TxState.Active) { continue; }\n\t\t    txQueue[k].state = TxState.Inactive;\n\t\t    Stash(stashRegistry[txQueue[k].sender]).inc_position(tx.amount);\n\t\t    Stash(stashRegistry[txQueue[k].receiver]).dec_position(tx.amount);\n\t\t    if (stashRegistry[txQueue[k].sender] >= 0) { break; }\n\t\t}\n\t    }\n\t}\n\tif (get_n_deficits() > 0) { return false; }\n\telse { return true; }\n    }\n    \n    function settle() onlyowner private returns(bool) {\n\tif (get_n_deficits() > 0) { throw; }\n\tfor (uint j = 0; j < stashNames.length; j++) {\n\t    Stash stash = Stash(stashRegistry[stashNames[j]]);\n\t    int net_diff = stash.getPosition() - stash.getBalance();\n\t    if (net_diff > 0) {\n\t\tstash.credit(net_diff);\n\t    } else if (net_diff < 0) {\n\t\tstash.safe_debit(-net_diff);\n\t    }\n\t}\n\tfor (uint k = 0; k < txQueue.length; k++) {\n\t    txQueue[k].state = TxState.Active;\n\t    var tx = txQueue[k];\n\t    Stash(stashRegistry[tx.sender]).dec_position(tx.amount);\n\t    Stash(stashRegistry[tx.receiver]).inc_position(tx.amount);\n\t}\n    }\n/*     /\\* only can be called by regulator *\\/ */\n/*     function resolve(int steps) onlyowner external returns(bool) { */\n/* \tfor (uint i = steps; i > 0: i--) { */\n/* \t    for (uint j = 0; i < stashNames.length; j++) { */\n/* \t\tif (stashRegistry[stashNames[i]].getPosition < 0) { */\n/*     for (uint k = 0; k < txQueue.length; k++) { */\n/*     tx = txQueue[k]; */\n/*     if (txQueue[k].sender == stashNames[i] && txQueue[k].state == TxState.Active) { */\n/*     txQueue[k].state = TxState.Inactive; */\n/*     stashRegistry[txQueue[k].sender].inc_position(_amount); */\n/*     stashRegistry[txQueue[k].receiver].dec_position(_amount); */\n/*     if (stashRegistry[txQueue[k].sender] >= 0) { break; } */\n/* } */\n/* } */\n/* \t\t} */\n/* \t    } */\n/* \t} */\n\t\n/* \treturn finished; */\n/*     } */\n\n\n    /* @depolyment, @live:\n       privateFor = MAS and participating node */\n    function transfer(bytes32 _src, bytes32 _dest, int _amount) {\n    \tStash src = Stash(stashRegistry[_src]);\n\tStash dest = Stash(stashRegistry[_dest]);\n\tif (_src == ownedStash) {\n\t    src.safe_debit(_amount);\n\t} else {\n\t    src.debit(_amount);\n\t}\n\tdest.credit(_amount);\n    }\n\n    /* @depolyment:\n       privateFor == MAS and owner node\n       amount == 0\n       \n       @live:\n       privateFor == MAS and owner node */\n    function pledge(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.credit(_amount);\n    }\n\n    /* @live:\n       privateFor = MAS and owner node */\n    function redeem(bytes32 _bankName, int _amount) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\tstash.safe_debit(_amount);\n    }\n\n    /* @live:\n       for stashes not owned by you this returns the net bilateral position */\n    function getStash(bytes32 _bankName) constant returns (int) {\n\tStash stash = Stash(stashRegistry[_bankName]);\n\treturn stash.getBalance();\n    }\n\n    function getQueueLength() public constant returns(uint) {\n        return txQueue.length;\n    }\n}\n\n\n/* Public contract for holding RefData */\n/* contract RefData is mortal { */\n    \n/*     struct transaction { */\n/* \tbool exists; */\n/* \tuint timestamp; */\n/* \tbool active; */\n/*     } */\n\n/*     struct Bank { */\n/* \tstring name; */\n/* \tbool authorized; */\n/* \tbool exists; */\n/* \taddress authorizedSender; */\n/*     } */\n\n/*     address public regulator; */\n    \n/*     mapping (bytes32 => transaction) public transactions; */\n    \n/*     mapping (address => Bank) public banks; */\n    \n/*     function addTransaction (bytes32 _transactionID) { */\n/*         transactions[_transactionID].exists=true; */\n/*         transactions[_transactionID].timestamp=block.timestamp; */\n/*         transactions[_transactionID].active=true; */\n/*     } */\n\n/*     function getTransactionExistance (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].exists); */\n/*     } */\n\n/*     function getTransactionState (bytes32 _transactionID) public constant  */\n/* \treturns (bool) { */\n/*         return (transactions[_transactionID].blocked); */\n/*     } */\n\n/*     function getTransactionTimestamp (bytes32 _transactionID) public constant  */\n/* \treturns (uint) { */\n/*         return (transactions[_transactionID].timestamp); */\n/*     } */\n\n/*     function bankExist (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].exists); */\n/*     } */\n\n/*     function bankAuthorized (address _contract) public constant  */\n/* \treturns (bool) { */\n/*         return (banks[_contract].authorized); */\n/*     } */\n\n/*     function getBankSender (address _contract) public constant  */\n/* \treturns (address) { */\n/*         return (banks[_contract].authorizedSender); */\n/*     } */\n\n/*     function activate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=true; */\n/* \t} */\n/*     } */\n\n/*     function inactivate(bytes32 _transactionID) onlyowner { */\n/* \tif (transactions[_transactionID].exists) { */\n/* \t    transactions[_transactionID].active=false; */\n/* \t} */\n/*     } */\n\n/*     function addBank (string _name, address _contract, address _sender) onlyowner { */\n/* \tbanks[_contract].name=_name; */\n/* \tbanks[_contract].exists=true; */\n/* \tbanks[_contract].authorized=true; */\n/* \tbanks[_contract].authorizedSender=_sender; */\n/*     } */\n\n/*     function blockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=false; */\n/*     } */\n\n/*     function unblockBank (address _contract) onlyowner { */\n/* \tbanks[_contract].authorized=true; */\n/*     } */\n\n/* } */\n","language":"Solidity","languageVersion":"0.4.11","compilerVersion":"0.4.11","compilerOptions":"--combined-json bin,abi,userdoc,devdoc --add-std --optimize","abiDefinition":[{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"inputs":[],"payable":false,"type":"constructor"}],"userDoc":{"methods":{}},"developerDoc":{"methods":{}}}}}